{
    "name": "opensearch",
    "description": "A Pulumi package for creating and managing opensearch cloud resources.",
    "keywords": [
        "pulumi",
        "opensearch",
        "category/cloud"
    ],
    "homepage": "https://github.com/mathmania/pulumi-opensearch",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`opensearch` Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch).",
    "repository": "https://github.com/mathmania/pulumi-opensearch",
    "publisher": "mathmania",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-opensearch/sdk/go/opensearch"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing opensearch cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-opensearch` repo](https://github.com/mathmania/pulumi-opensearch/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-opensearch` repo](https://github.com/opensearch-project/terraform-provider-opensearch/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-opensearch` repo](https://github.com/mathmania/pulumi-opensearch/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-opensearch` repo](https://github.com/opensearch-project/terraform-provider-opensearch/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS opensearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS opensearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS opensearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS opensearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to opensearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS opensearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to opensearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to opensearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the opensearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to opensearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "opensearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to opensearch using basic auth\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS opensearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the opensearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "Opensearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to opensearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "defaults": [
            "url"
        ]
    },
    "types": {
        "opensearch:index/AuditConfigAudit:AuditConfigAudit": {
            "properties": {
                "disabledRestCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabledTransportCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableRest": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableTransport": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "excludeSensitiveHeaders": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignoreRequests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "logRequestBody": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resolveBulkRequests": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resolveIndices": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "opensearch:index/AuditConfigCompliance:AuditConfigCompliance": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalConfig": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "internalConfig": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readIgnoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readMetadataOnly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readWatchedFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/AuditConfigComplianceReadWatchedField:AuditConfigComplianceReadWatchedField"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeIgnoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeLogDiffs": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeMetadataOnly": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeWatchedIndices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "opensearch:index/AuditConfigComplianceReadWatchedField:AuditConfigComplianceReadWatchedField": {
            "properties": {
                "fields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "index": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fields",
                "index"
            ]
        },
        "opensearch:index/RoleIndexPermission:RoleIndexPermission": {
            "properties": {
                "allowedActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "documentLevelSecurity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldLevelSecurities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maskedFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "opensearch:index/RoleTenantPermission:RoleTenantPermission": {
            "properties": {
                "allowedActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tenantPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the opensearch package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS opensearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS opensearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS opensearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS opensearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to opensearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS opensearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to opensearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to opensearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the opensearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to opensearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "opensearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to opensearch using basic auth\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS opensearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the opensearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "Opensearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to opensearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "required": [
            "url"
        ],
        "inputProperties": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS opensearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS opensearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS opensearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS opensearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to opensearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS opensearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to opensearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to opensearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the opensearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to opensearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "opensearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to opensearch using basic auth\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS opensearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the opensearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "Opensearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to opensearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "requiredInputs": [
            "url"
        ]
    },
    "resources": {
        "opensearch:index/auditConfig:AuditConfig": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = new opensearch.AuditConfig(\"test\", {\n    audit: {\n        disabledRestCategories: [\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        disabledTransportCategories: [\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        enableRest: true,\n        enableTransport: true,\n        // Note: if set false, AWS OpenSearch will return HTTP 409 (Conflict)\n        excludeSensitiveHeaders: true,\n        ignoreRequests: [\n            \"SearchRequest\",\n            \"indices:data/read/*\",\n            \"/_cluster/health\",\n        ],\n        ignoreUsers: [\"dashboardserver\"],\n        logRequestBody: true,\n        resolveBulkRequests: true,\n        resolveIndices: true,\n    },\n    compliance: {\n        enabled: true,\n        externalConfig: false,\n        // Note: if both internal/external are set true, AWS OpenSearch will return HTTP 409 (Conflict)\n        internalConfig: true,\n        readIgnoreUsers: [\"read-ignore-1\"],\n        readMetadataOnly: true,\n        readWatchedFields: [\n            {\n                fields: [\n                    \"field-1\",\n                    \"field-2\",\n                ],\n                index: \"read-index-1\",\n            },\n            {\n                fields: [\"field-3\"],\n                index: \"read-index-2\",\n            },\n        ],\n        writeIgnoreUsers: [\"write-ignore-1\"],\n        writeLogDiffs: false,\n        writeMetadataOnly: true,\n        writeWatchedIndices: [\n            \"write-index-1\",\n            \"write-index-2\",\n            \"log-*\",\n            \"*\",\n        ],\n    },\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.AuditConfig(\"test\",\n    audit=opensearch.AuditConfigAuditArgs(\n        disabled_rest_categories=[\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        disabled_transport_categories=[\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        enable_rest=True,\n        enable_transport=True,\n        exclude_sensitive_headers=True,\n        ignore_requests=[\n            \"SearchRequest\",\n            \"indices:data/read/*\",\n            \"/_cluster/health\",\n        ],\n        ignore_users=[\"dashboardserver\"],\n        log_request_body=True,\n        resolve_bulk_requests=True,\n        resolve_indices=True,\n    ),\n    compliance=opensearch.AuditConfigComplianceArgs(\n        enabled=True,\n        external_config=False,\n        internal_config=True,\n        read_ignore_users=[\"read-ignore-1\"],\n        read_metadata_only=True,\n        read_watched_fields=[\n            opensearch.AuditConfigComplianceReadWatchedFieldArgs(\n                fields=[\n                    \"field-1\",\n                    \"field-2\",\n                ],\n                index=\"read-index-1\",\n            ),\n            opensearch.AuditConfigComplianceReadWatchedFieldArgs(\n                fields=[\"field-3\"],\n                index=\"read-index-2\",\n            ),\n        ],\n        write_ignore_users=[\"write-ignore-1\"],\n        write_log_diffs=False,\n        write_metadata_only=True,\n        write_watched_indices=[\n            \"write-index-1\",\n            \"write-index-2\",\n            \"log-*\",\n            \"*\",\n        ],\n    ),\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Opensearch.AuditConfig(\"test\", new Opensearch.AuditConfigArgs\n        {\n            Audit = new Opensearch.Inputs.AuditConfigAuditArgs\n            {\n                DisabledRestCategories = \n                {\n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\",\n                },\n                DisabledTransportCategories = \n                {\n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\",\n                },\n                EnableRest = true,\n                EnableTransport = true,\n                ExcludeSensitiveHeaders = true,\n                IgnoreRequests = \n                {\n                    \"SearchRequest\",\n                    \"indices:data/read/*\",\n                    \"/_cluster/health\",\n                },\n                IgnoreUsers = \n                {\n                    \"dashboardserver\",\n                },\n                LogRequestBody = true,\n                ResolveBulkRequests = true,\n                ResolveIndices = true,\n            },\n            Compliance = new Opensearch.Inputs.AuditConfigComplianceArgs\n            {\n                Enabled = true,\n                ExternalConfig = false,\n                InternalConfig = true,\n                ReadIgnoreUsers = \n                {\n                    \"read-ignore-1\",\n                },\n                ReadMetadataOnly = true,\n                ReadWatchedFields = \n                {\n                    new Opensearch.Inputs.AuditConfigComplianceReadWatchedFieldArgs\n                    {\n                        Fields = \n                        {\n                            \"field-1\",\n                            \"field-2\",\n                        },\n                        Index = \"read-index-1\",\n                    },\n                    new Opensearch.Inputs.AuditConfigComplianceReadWatchedFieldArgs\n                    {\n                        Fields = \n                        {\n                            \"field-3\",\n                        },\n                        Index = \"read-index-2\",\n                    },\n                },\n                WriteIgnoreUsers = \n                {\n                    \"write-ignore-1\",\n                },\n                WriteLogDiffs = false,\n                WriteMetadataOnly = true,\n                WriteWatchedIndices = \n                {\n                    \"write-index-1\",\n                    \"write-index-2\",\n                    \"log-*\",\n                    \"*\",\n                },\n            },\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewAuditConfig(ctx, \"test\", \u0026opensearch.AuditConfigArgs{\n\t\t\tAudit: \u0026AuditConfigAuditArgs{\n\t\t\t\tDisabledRestCategories: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"GRANTED_PRIVILEGES\"),\n\t\t\t\t\tpulumi.String(\"AUTHENTICATED\"),\n\t\t\t\t},\n\t\t\t\tDisabledTransportCategories: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"GRANTED_PRIVILEGES\"),\n\t\t\t\t\tpulumi.String(\"AUTHENTICATED\"),\n\t\t\t\t},\n\t\t\t\tEnableRest:              pulumi.Bool(true),\n\t\t\t\tEnableTransport:         pulumi.Bool(true),\n\t\t\t\tExcludeSensitiveHeaders: pulumi.Bool(true),\n\t\t\t\tIgnoreRequests: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"SearchRequest\"),\n\t\t\t\t\tpulumi.String(\"indices:data/read/*\"),\n\t\t\t\t\tpulumi.String(\"/_cluster/health\"),\n\t\t\t\t},\n\t\t\t\tIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"dashboardserver\"),\n\t\t\t\t},\n\t\t\t\tLogRequestBody:      pulumi.Bool(true),\n\t\t\t\tResolveBulkRequests: pulumi.Bool(true),\n\t\t\t\tResolveIndices:      pulumi.Bool(true),\n\t\t\t},\n\t\t\tCompliance: \u0026AuditConfigComplianceArgs{\n\t\t\t\tEnabled:        pulumi.Bool(true),\n\t\t\t\tExternalConfig: pulumi.Bool(false),\n\t\t\t\tInternalConfig: pulumi.Bool(true),\n\t\t\t\tReadIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"read-ignore-1\"),\n\t\t\t\t},\n\t\t\t\tReadMetadataOnly: pulumi.Bool(true),\n\t\t\t\tReadWatchedFields: AuditConfigComplianceReadWatchedFieldArray{\n\t\t\t\t\t\u0026AuditConfigComplianceReadWatchedFieldArgs{\n\t\t\t\t\t\tFields: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"field-1\"),\n\t\t\t\t\t\t\tpulumi.String(\"field-2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIndex: pulumi.String(\"read-index-1\"),\n\t\t\t\t\t},\n\t\t\t\t\t\u0026AuditConfigComplianceReadWatchedFieldArgs{\n\t\t\t\t\t\tFields: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"field-3\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIndex: pulumi.String(\"read-index-2\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tWriteIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"write-ignore-1\"),\n\t\t\t\t},\n\t\t\t\tWriteLogDiffs:     pulumi.Bool(false),\n\t\t\t\tWriteMetadataOnly: pulumi.Bool(true),\n\t\t\t\tWriteWatchedIndices: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"write-index-1\"),\n\t\t\t\t\tpulumi.String(\"write-index-2\"),\n\t\t\t\t\tpulumi.String(\"log-*\"),\n\t\t\t\t\tpulumi.String(\"*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.AuditConfig;\nimport com.pulumi.opensearch.AuditConfigArgs;\nimport com.pulumi.opensearch.inputs.AuditConfigAuditArgs;\nimport com.pulumi.opensearch.inputs.AuditConfigComplianceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AuditConfig(\"test\", AuditConfigArgs.builder()        \n            .audit(AuditConfigAuditArgs.builder()\n                .disabledRestCategories(                \n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\")\n                .disabledTransportCategories(                \n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\")\n                .enableRest(true)\n                .enableTransport(true)\n                .excludeSensitiveHeaders(true)\n                .ignoreRequests(                \n                    \"SearchRequest\",\n                    \"indices:data/read/*\",\n                    \"/_cluster/health\")\n                .ignoreUsers(\"dashboardserver\")\n                .logRequestBody(true)\n                .resolveBulkRequests(true)\n                .resolveIndices(true)\n                .build())\n            .compliance(AuditConfigComplianceArgs.builder()\n                .enabled(true)\n                .externalConfig(false)\n                .internalConfig(true)\n                .readIgnoreUsers(\"read-ignore-1\")\n                .readMetadataOnly(true)\n                .readWatchedFields(                \n                    AuditConfigComplianceReadWatchedFieldArgs.builder()\n                        .fields(                        \n                            \"field-1\",\n                            \"field-2\")\n                        .index(\"read-index-1\")\n                        .build(),\n                    AuditConfigComplianceReadWatchedFieldArgs.builder()\n                        .fields(\"field-3\")\n                        .index(\"read-index-2\")\n                        .build())\n                .writeIgnoreUsers(\"write-ignore-1\")\n                .writeLogDiffs(false)\n                .writeMetadataOnly(true)\n                .writeWatchedIndices(                \n                    \"write-index-1\",\n                    \"write-index-2\",\n                    \"log-*\",\n                    \"*\")\n                .build())\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:AuditConfig\n    properties:\n      audit:\n        disabledRestCategories:\n          - GRANTED_PRIVILEGES\n          - AUTHENTICATED\n        disabledTransportCategories:\n          - GRANTED_PRIVILEGES\n          - AUTHENTICATED\n        enableRest: true\n        enableTransport: true\n        excludeSensitiveHeaders: true\n        ignoreRequests:\n          - SearchRequest\n          - indices:data/read/*\n          - /_cluster/health\n        ignoreUsers:\n          - dashboardserver\n        logRequestBody: true\n        resolveBulkRequests: true\n        resolveIndices: true\n      compliance:\n        enabled: true\n        externalConfig: false\n        internalConfig: true\n        readIgnoreUsers:\n          - read-ignore-1\n        readMetadataOnly: true\n        readWatchedFields:\n          - fields:\n              - field-1\n              - field-2\n            index: read-index-1\n          - fields:\n              - field-3\n            index: read-index-2\n        writeIgnoreUsers:\n          - write-ignore-1\n        writeLogDiffs: false\n        writeMetadataOnly: true\n        writeWatchedIndices:\n          - write-index-1\n          - write-index-2\n          - log-*\n          - '*'\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# Import by name\n\n```sh\n $ pulumi import opensearch:index/auditConfig:AuditConfig test_config my-config\n```\n\n ",
            "properties": {
                "audit": {
                    "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                },
                "compliance": {
                    "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                },
                "enabled": {
                    "type": "boolean"
                }
            },
            "required": [
                "enabled"
            ],
            "inputProperties": {
                "audit": {
                    "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                },
                "compliance": {
                    "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                },
                "enabled": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuditConfig resources.\n",
                "properties": {
                    "audit": {
                        "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                    },
                    "compliance": {
                        "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                    },
                    "enabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/clusterSettings:ClusterSettings": {
            "description": "Manages a cluster's (persistent) settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst global = new opensearch.ClusterSettings(\"global\", {\n    actionAutoCreateIndex: \"my-index-000001,index10,-index1*,+ind*\",\n    clusterMaxShardsPerNode: 10,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\nglobal_ = opensearch.ClusterSettings(\"global\",\n    action_auto_create_index=\"my-index-000001,index10,-index1*,+ind*\",\n    cluster_max_shards_per_node=10)\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @global = new Opensearch.ClusterSettings(\"global\", new Opensearch.ClusterSettingsArgs\n        {\n            ActionAutoCreateIndex = \"my-index-000001,index10,-index1*,+ind*\",\n            ClusterMaxShardsPerNode = 10,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewClusterSettings(ctx, \"global\", \u0026opensearch.ClusterSettingsArgs{\n\t\t\tActionAutoCreateIndex:   pulumi.String(\"my-index-000001,index10,-index1*,+ind*\"),\n\t\t\tClusterMaxShardsPerNode: pulumi.Int(10),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ClusterSettings;\nimport com.pulumi.opensearch.ClusterSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var global = new ClusterSettings(\"global\", ClusterSettingsArgs.builder()        \n            .actionAutoCreateIndex(\"my-index-000001,index10,-index1*,+ind*\")\n            .clusterMaxShardsPerNode(10)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  global:\n    type: opensearch:ClusterSettings\n    properties:\n      actionAutoCreateIndex: my-index-000001,index10,-index1*,+ind*\n      clusterMaxShardsPerNode: 10\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "actionAutoCreateIndex": {
                    "type": "string",
                    "description": "Whether to automatically create an index if it doesn’t already exist and apply any configured index template\n"
                },
                "actionDestructiveRequiresName": {
                    "type": "boolean",
                    "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with\n_all or use wildcards\n"
                },
                "clusterBlocksReadOnly": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                },
                "clusterBlocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                },
                "clusterIndicesCloseEnable": {
                    "type": "boolean",
                    "description": "If false, you cannot close open indices\n"
                },
                "clusterInfoUpdateInterval": {
                    "type": "string",
                    "description": "A time string controlling how often Opensearch should check on disk usage for each node in the cluster\n"
                },
                "clusterMaxShardsPerNode": {
                    "type": "integer",
                    "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen\ndata nodes; shards for closed indices do not count toward this limit\n"
                },
                "clusterMaxShardsPerNodeFrozen": {
                    "type": "integer",
                    "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward\nthis limit, a cluster with no frozen data nodes is unlimited.\n"
                },
                "clusterNoMasterBlock": {
                    "type": "string",
                    "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                },
                "clusterPersistentTasksAllocationEnable": {
                    "type": "string",
                    "description": "Whether allocation for persistent tasks is active (all, none)\n"
                },
                "clusterPersistentTasksAllocationRecheckInterval": {
                    "type": "string",
                    "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned\nto nodes\n"
                },
                "clusterRoutingAllocationAllowRebalance": {
                    "type": "string",
                    "description": "Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)\n"
                },
                "clusterRoutingAllocationAwarenessAttributes": {
                    "type": "string",
                    "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                },
                "clusterRoutingAllocationBalanceIndex": {
                    "type": "number",
                    "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize\nthe number of shards per index across all nodes\n"
                },
                "clusterRoutingAllocationBalanceShard": {
                    "type": "number",
                    "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the\nnumber of shards across all nodes\n"
                },
                "clusterRoutingAllocationBalanceThreshold": {
                    "type": "number",
                    "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less\naggressive about optimizing the shard balance\n"
                },
                "clusterRoutingAllocationClusterConcurrentRebalance": {
                    "type": "integer",
                    "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                },
                "clusterRoutingAllocationDiskIncludeRelocations": {
                    "type": "boolean",
                    "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing\na node’s disk usage\n"
                },
                "clusterRoutingAllocationDiskThresholdEnabled": {
                    "type": "boolean",
                    "description": "Whether the disk allocation decider is active\n"
                },
                "clusterRoutingAllocationDiskWatermarkHigh": {
                    "type": "string",
                    "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                },
                "clusterRoutingAllocationDiskWatermarkLow": {
                    "type": "string",
                    "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                },
                "clusterRoutingAllocationEnable": {
                    "type": "string",
                    "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                },
                "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                    "type": "integer",
                    "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on\nthe node\n"
                },
                "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                    "type": "integer",
                    "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on\nthe node\n"
                },
                "clusterRoutingAllocationNodeConcurrentRecoveries": {
                    "type": "integer",
                    "description": "A shortcut to set both incoming and outgoing recoveries\n"
                },
                "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                    "type": "integer",
                    "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                },
                "clusterRoutingAllocationSameShardHost": {
                    "type": "boolean",
                    "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are\nstarted on the host\n"
                },
                "clusterRoutingAllocationTotalShardsPerNode": {
                    "type": "integer",
                    "description": "Maximum number of primary and replica shards allocated to each node\n"
                },
                "clusterRoutingRebalanceEnable": {
                    "type": "string",
                    "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                },
                "indicesBreakerFielddataLimit": {
                    "type": "string",
                    "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this\nlimit, an error is returned\n"
                },
                "indicesBreakerFielddataOverhead": {
                    "type": "number",
                    "description": "A constant that all field data estimations are multiplied by\n"
                },
                "indicesBreakerRequestLimit": {
                    "type": "string",
                    "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from\nexceeding\n"
                },
                "indicesBreakerRequestOverhead": {
                    "type": "number",
                    "description": "A constant that all request estimations are multiplied by\n"
                },
                "indicesBreakerTotalLimit": {
                    "type": "string",
                    "description": "The percentage of total amount of memory that can be used across all breakers\n"
                },
                "indicesRecoveryMaxBytesPerSec": {
                    "type": "string",
                    "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                },
                "networkBreakerInflightRequestsLimit": {
                    "type": "string",
                    "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                },
                "networkBreakerInflightRequestsOverhead": {
                    "type": "number",
                    "description": "A constant that all in flight requests estimations are multiplied by\n"
                },
                "scriptMaxCompilationsRate": {
                    "type": "string",
                    "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as\ncompilations divided by a time string\n"
                },
                "searchDefaultSearchTimeout": {
                    "type": "string",
                    "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                }
            },
            "inputProperties": {
                "actionAutoCreateIndex": {
                    "type": "string",
                    "description": "Whether to automatically create an index if it doesn’t already exist and apply any configured index template\n"
                },
                "actionDestructiveRequiresName": {
                    "type": "boolean",
                    "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with\n_all or use wildcards\n"
                },
                "clusterBlocksReadOnly": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                },
                "clusterBlocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                },
                "clusterIndicesCloseEnable": {
                    "type": "boolean",
                    "description": "If false, you cannot close open indices\n"
                },
                "clusterInfoUpdateInterval": {
                    "type": "string",
                    "description": "A time string controlling how often Opensearch should check on disk usage for each node in the cluster\n"
                },
                "clusterMaxShardsPerNode": {
                    "type": "integer",
                    "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen\ndata nodes; shards for closed indices do not count toward this limit\n"
                },
                "clusterMaxShardsPerNodeFrozen": {
                    "type": "integer",
                    "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward\nthis limit, a cluster with no frozen data nodes is unlimited.\n"
                },
                "clusterNoMasterBlock": {
                    "type": "string",
                    "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                },
                "clusterPersistentTasksAllocationEnable": {
                    "type": "string",
                    "description": "Whether allocation for persistent tasks is active (all, none)\n"
                },
                "clusterPersistentTasksAllocationRecheckInterval": {
                    "type": "string",
                    "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned\nto nodes\n"
                },
                "clusterRoutingAllocationAllowRebalance": {
                    "type": "string",
                    "description": "Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)\n"
                },
                "clusterRoutingAllocationAwarenessAttributes": {
                    "type": "string",
                    "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                },
                "clusterRoutingAllocationBalanceIndex": {
                    "type": "number",
                    "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize\nthe number of shards per index across all nodes\n"
                },
                "clusterRoutingAllocationBalanceShard": {
                    "type": "number",
                    "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the\nnumber of shards across all nodes\n"
                },
                "clusterRoutingAllocationBalanceThreshold": {
                    "type": "number",
                    "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less\naggressive about optimizing the shard balance\n"
                },
                "clusterRoutingAllocationClusterConcurrentRebalance": {
                    "type": "integer",
                    "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                },
                "clusterRoutingAllocationDiskIncludeRelocations": {
                    "type": "boolean",
                    "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing\na node’s disk usage\n"
                },
                "clusterRoutingAllocationDiskThresholdEnabled": {
                    "type": "boolean",
                    "description": "Whether the disk allocation decider is active\n"
                },
                "clusterRoutingAllocationDiskWatermarkHigh": {
                    "type": "string",
                    "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                },
                "clusterRoutingAllocationDiskWatermarkLow": {
                    "type": "string",
                    "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                },
                "clusterRoutingAllocationEnable": {
                    "type": "string",
                    "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                },
                "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                    "type": "integer",
                    "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on\nthe node\n"
                },
                "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                    "type": "integer",
                    "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on\nthe node\n"
                },
                "clusterRoutingAllocationNodeConcurrentRecoveries": {
                    "type": "integer",
                    "description": "A shortcut to set both incoming and outgoing recoveries\n"
                },
                "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                    "type": "integer",
                    "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                },
                "clusterRoutingAllocationSameShardHost": {
                    "type": "boolean",
                    "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are\nstarted on the host\n"
                },
                "clusterRoutingAllocationTotalShardsPerNode": {
                    "type": "integer",
                    "description": "Maximum number of primary and replica shards allocated to each node\n"
                },
                "clusterRoutingRebalanceEnable": {
                    "type": "string",
                    "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                },
                "indicesBreakerFielddataLimit": {
                    "type": "string",
                    "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this\nlimit, an error is returned\n"
                },
                "indicesBreakerFielddataOverhead": {
                    "type": "number",
                    "description": "A constant that all field data estimations are multiplied by\n"
                },
                "indicesBreakerRequestLimit": {
                    "type": "string",
                    "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from\nexceeding\n"
                },
                "indicesBreakerRequestOverhead": {
                    "type": "number",
                    "description": "A constant that all request estimations are multiplied by\n"
                },
                "indicesBreakerTotalLimit": {
                    "type": "string",
                    "description": "The percentage of total amount of memory that can be used across all breakers\n"
                },
                "indicesRecoveryMaxBytesPerSec": {
                    "type": "string",
                    "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                },
                "networkBreakerInflightRequestsLimit": {
                    "type": "string",
                    "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                },
                "networkBreakerInflightRequestsOverhead": {
                    "type": "number",
                    "description": "A constant that all in flight requests estimations are multiplied by\n"
                },
                "scriptMaxCompilationsRate": {
                    "type": "string",
                    "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as\ncompilations divided by a time string\n"
                },
                "searchDefaultSearchTimeout": {
                    "type": "string",
                    "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterSettings resources.\n",
                "properties": {
                    "actionAutoCreateIndex": {
                        "type": "string",
                        "description": "Whether to automatically create an index if it doesn’t already exist and apply any configured index template\n"
                    },
                    "actionDestructiveRequiresName": {
                        "type": "boolean",
                        "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with\n_all or use wildcards\n"
                    },
                    "clusterBlocksReadOnly": {
                        "type": "boolean",
                        "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                    },
                    "clusterBlocksReadOnlyAllowDelete": {
                        "type": "boolean",
                        "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                    },
                    "clusterIndicesCloseEnable": {
                        "type": "boolean",
                        "description": "If false, you cannot close open indices\n"
                    },
                    "clusterInfoUpdateInterval": {
                        "type": "string",
                        "description": "A time string controlling how often Opensearch should check on disk usage for each node in the cluster\n"
                    },
                    "clusterMaxShardsPerNode": {
                        "type": "integer",
                        "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen\ndata nodes; shards for closed indices do not count toward this limit\n"
                    },
                    "clusterMaxShardsPerNodeFrozen": {
                        "type": "integer",
                        "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward\nthis limit, a cluster with no frozen data nodes is unlimited.\n"
                    },
                    "clusterNoMasterBlock": {
                        "type": "string",
                        "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                    },
                    "clusterPersistentTasksAllocationEnable": {
                        "type": "string",
                        "description": "Whether allocation for persistent tasks is active (all, none)\n"
                    },
                    "clusterPersistentTasksAllocationRecheckInterval": {
                        "type": "string",
                        "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned\nto nodes\n"
                    },
                    "clusterRoutingAllocationAllowRebalance": {
                        "type": "string",
                        "description": "Specify when shard rebalancing is allowed (always, indices_primaries_active, indices_all_active)\n"
                    },
                    "clusterRoutingAllocationAwarenessAttributes": {
                        "type": "string",
                        "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                    },
                    "clusterRoutingAllocationBalanceIndex": {
                        "type": "number",
                        "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize\nthe number of shards per index across all nodes\n"
                    },
                    "clusterRoutingAllocationBalanceShard": {
                        "type": "number",
                        "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the\nnumber of shards across all nodes\n"
                    },
                    "clusterRoutingAllocationBalanceThreshold": {
                        "type": "number",
                        "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less\naggressive about optimizing the shard balance\n"
                    },
                    "clusterRoutingAllocationClusterConcurrentRebalance": {
                        "type": "integer",
                        "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                    },
                    "clusterRoutingAllocationDiskIncludeRelocations": {
                        "type": "boolean",
                        "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing\na node’s disk usage\n"
                    },
                    "clusterRoutingAllocationDiskThresholdEnabled": {
                        "type": "boolean",
                        "description": "Whether the disk allocation decider is active\n"
                    },
                    "clusterRoutingAllocationDiskWatermarkHigh": {
                        "type": "string",
                        "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                    },
                    "clusterRoutingAllocationDiskWatermarkLow": {
                        "type": "string",
                        "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                    },
                    "clusterRoutingAllocationEnable": {
                        "type": "string",
                        "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                        "type": "integer",
                        "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on\nthe node\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                        "type": "integer",
                        "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on\nthe node\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentRecoveries": {
                        "type": "integer",
                        "description": "A shortcut to set both incoming and outgoing recoveries\n"
                    },
                    "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                        "type": "integer",
                        "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                    },
                    "clusterRoutingAllocationSameShardHost": {
                        "type": "boolean",
                        "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are\nstarted on the host\n"
                    },
                    "clusterRoutingAllocationTotalShardsPerNode": {
                        "type": "integer",
                        "description": "Maximum number of primary and replica shards allocated to each node\n"
                    },
                    "clusterRoutingRebalanceEnable": {
                        "type": "string",
                        "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                    },
                    "indicesBreakerFielddataLimit": {
                        "type": "string",
                        "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this\nlimit, an error is returned\n"
                    },
                    "indicesBreakerFielddataOverhead": {
                        "type": "number",
                        "description": "A constant that all field data estimations are multiplied by\n"
                    },
                    "indicesBreakerRequestLimit": {
                        "type": "string",
                        "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from\nexceeding\n"
                    },
                    "indicesBreakerRequestOverhead": {
                        "type": "number",
                        "description": "A constant that all request estimations are multiplied by\n"
                    },
                    "indicesBreakerTotalLimit": {
                        "type": "string",
                        "description": "The percentage of total amount of memory that can be used across all breakers\n"
                    },
                    "indicesRecoveryMaxBytesPerSec": {
                        "type": "string",
                        "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                    },
                    "networkBreakerInflightRequestsLimit": {
                        "type": "string",
                        "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                    },
                    "networkBreakerInflightRequestsOverhead": {
                        "type": "number",
                        "description": "A constant that all in flight requests estimations are multiplied by\n"
                    },
                    "scriptMaxCompilationsRate": {
                        "type": "string",
                        "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as\ncompilations divided by a time string\n"
                    },
                    "searchDefaultSearchTimeout": {
                        "type": "string",
                        "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/componentTemplate:ComponentTemplate": {
            "description": "Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases. You cannot directly apply a component template to a data stream or index. To be applied, a component template must be included in an index template’s `composed_of` list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = new opensearch.ComponentTemplate(\"test\", {\n    body: `{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.ComponentTemplate(\"test\", body=\"\"\"{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Opensearch.ComponentTemplate(\"test\", new Opensearch.ComponentTemplateArgs\n        {\n            Body = @\"{\n  \"\"template\"\": {\n    \"\"settings\"\": {\n      \"\"index\"\": {\n        \"\"number_of_shards\"\": 1\n      }\n    },\n    \"\"mappings\"\": {\n      \"\"properties\"\": {\n        \"\"host_name\"\": {\n          \"\"type\"\": \"\"keyword\"\"\n        },\n        \"\"created_at\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"EEE MMM dd HH:mm:ss Z yyyy\"\"\n        }\n      }\n    },\n    \"\"aliases\"\": {\n      \"\"mydata\"\": { }\n    }\n  }\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewComponentTemplate(ctx, \"test\", \u0026opensearch.ComponentTemplateArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"template\\\": {\\n    \\\"settings\\\": {\\n      \\\"index\\\": {\\n        \\\"number_of_shards\\\": 1\\n      }\\n    },\\n    \\\"mappings\\\": {\\n      \\\"properties\\\": {\\n        \\\"host_name\\\": {\\n          \\\"type\\\": \\\"keyword\\\"\\n        },\\n        \\\"created_at\\\": {\\n          \\\"type\\\": \\\"date\\\",\\n          \\\"format\\\": \\\"EEE MMM dd HH:mm:ss Z yyyy\\\"\\n        }\\n      }\\n    },\\n    \\\"aliases\\\": {\\n      \\\"mydata\\\": { }\\n    }\\n  }\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComponentTemplate;\nimport com.pulumi.opensearch.ComponentTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ComponentTemplate(\"test\", ComponentTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:ComponentTemplate\n    properties:\n      body: |+\n        {\n          \"template\": {\n            \"settings\": {\n              \"index\": {\n                \"number_of_shards\": 1\n              }\n            },\n            \"mappings\": {\n              \"properties\": {\n                \"host_name\": {\n                  \"type\": \"keyword\"\n                },\n                \"created_at\": {\n                  \"type\": \"date\",\n                  \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n                }\n              }\n            },\n            \"aliases\": {\n              \"mydata\": { }\n            }\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# Import by name\n\n```sh\n $ pulumi import opensearch:index/componentTemplate:ComponentTemplate test terraform-test\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComponentTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the component template to create.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/composableIndexTemplate:ComposableIndexTemplate": {
            "description": "Provides an Composable index template resource. This resource uses the `/_index_template` endpoint of the API that is available since version 7.8. Use `opensearch.IndexTemplate` if you are using older versions or if you want to keep using legacy Index Templates in versions 7.8+.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst template1 = new opensearch.ComposableIndexTemplate(\"template_1\", {\n    body: `{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntemplate1 = opensearch.ComposableIndexTemplate(\"template1\", body=\"\"\"{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var template1 = new Opensearch.ComposableIndexTemplate(\"template1\", new Opensearch.ComposableIndexTemplateArgs\n        {\n            Body = @\"{\n  \"\"index_patterns\"\": [\"\"te*\"\", \"\"bar*\"\"],\n  \"\"template\"\": {\n    \"\"settings\"\": {\n      \"\"index\"\": {\n        \"\"number_of_shards\"\": 1\n      }\n    },\n    \"\"mappings\"\": {\n      \"\"properties\"\": {\n        \"\"host_name\"\": {\n          \"\"type\"\": \"\"keyword\"\"\n        },\n        \"\"created_at\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"EEE MMM dd HH:mm:ss Z yyyy\"\"\n        }\n      }\n    },\n    \"\"aliases\"\": {\n      \"\"mydata\"\": { }\n    }\n  },\n  \"\"priority\"\": 200,\n  \"\"version\"\": 3\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewComposableIndexTemplate(ctx, \"template1\", \u0026opensearch.ComposableIndexTemplateArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"index_patterns\\\": [\\\"te*\\\", \\\"bar*\\\"],\\n  \\\"template\\\": {\\n    \\\"settings\\\": {\\n      \\\"index\\\": {\\n        \\\"number_of_shards\\\": 1\\n      }\\n    },\\n    \\\"mappings\\\": {\\n      \\\"properties\\\": {\\n        \\\"host_name\\\": {\\n          \\\"type\\\": \\\"keyword\\\"\\n        },\\n        \\\"created_at\\\": {\\n          \\\"type\\\": \\\"date\\\",\\n          \\\"format\\\": \\\"EEE MMM dd HH:mm:ss Z yyyy\\\"\\n        }\\n      }\\n    },\\n    \\\"aliases\\\": {\\n      \\\"mydata\\\": { }\\n    }\\n  },\\n  \\\"priority\\\": 200,\\n  \\\"version\\\": 3\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComposableIndexTemplate;\nimport com.pulumi.opensearch.ComposableIndexTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var template1 = new ComposableIndexTemplate(\"template1\", ComposableIndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": 1\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  template1:\n    type: opensearch:ComposableIndexTemplate\n    properties:\n      body: |+\n        {\n          \"index_patterns\": [\"te*\", \"bar*\"],\n          \"template\": {\n            \"settings\": {\n              \"index\": {\n                \"number_of_shards\": 1\n              }\n            },\n            \"mappings\": {\n              \"properties\": {\n                \"host_name\": {\n                  \"type\": \"keyword\"\n                },\n                \"created_at\": {\n                  \"type\": \"date\",\n                  \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n                }\n              }\n            },\n            \"aliases\": {\n              \"mydata\": { }\n            }\n          },\n          \"priority\": 200,\n          \"version\": 3\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/composableIndexTemplate:ComposableIndexTemplate template_1 template_1\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComposableIndexTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the index template.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dashboardObject:DashboardObject": {
            "description": "Provides an OpenSearch Dashboards object resource. This resource interacts directly with the underlying OpenSearch index backing Dashboards, so the format must match what Dashboards the version of Dashboards is expecting. Dashboards v5 and v6 will export all objects in Dashboards v5 format, so the exported objects cannot be used as a source for `body` in this resource - directly pulling the JSON from a Dashboards index of the same version of OpenSearch targeted by the provider is a workaround.\n\nWith the removal of mapping types in OpenSearch, the Dashboards index changed from v5 to \u003e= v6, previously the document mapping type had the Dashboards object type, however, the `_type` going forward is `doc` and the type is within the document, see below. Using v5 doc types in v6 and above will result in errors from OpenSearch after one or more document types are used.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst testVisualizationV6 = new opensearch.DashboardObject(\"test_visualization_v6\", {\n    body: `[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\\\"title\\\\\":\\\\\"Total response time percentiles\\\\\",\\\\\"type\\\\\":\\\\\"line\\\\\",\\\\\"params\\\\\":{\\\\\"addTooltip\\\\\":true,\\\\\"addLegend\\\\\":true,\\\\\"legendPosition\\\\\":\\\\\"right\\\\\",\\\\\"showCircles\\\\\":true,\\\\\"interpolate\\\\\":\\\\\"linear\\\\\",\\\\\"scale\\\\\":\\\\\"linear\\\\\",\\\\\"drawLinesBetweenPoints\\\\\":true,\\\\\"radiusRatio\\\\\":9,\\\\\"times\\\\\":[],\\\\\"addTimeMarker\\\\\":false,\\\\\"defaultYExtents\\\\\":false,\\\\\"setYExtents\\\\\":false},\\\\\"aggs\\\\\":[{\\\\\"id\\\\\":\\\\\"1\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"percentiles\\\\\",\\\\\"schema\\\\\":\\\\\"metric\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"app.total_time\\\\\",\\\\\"percents\\\\\":[50,90,95]}},{\\\\\"id\\\\\":\\\\\"2\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"date_histogram\\\\\",\\\\\"schema\\\\\":\\\\\"segment\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"@timestamp\\\\\",\\\\\"interval\\\\\":\\\\\"auto\\\\\",\\\\\"customInterval\\\\\":\\\\\"2h\\\\\",\\\\\"min_doc_count\\\\\":1,\\\\\"extended_bounds\\\\\":{}}},{\\\\\"id\\\\\":\\\\\"3\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"terms\\\\\",\\\\\"schema\\\\\":\\\\\"group\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"system.syslog.program\\\\\",\\\\\"size\\\\\":5,\\\\\"order\\\\\":\\\\\"desc\\\\\",\\\\\"orderBy\\\\\":\\\\\"_term\\\\\"}}],\\\\\"listeners\\\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n`,\n});\nconst testVisualizationV7 = new opensearch.DashboardObject(\"test_visualization_v7\", {\n    body: `[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\\\"title\\\\\":\\\\\"Total response time percentiles\\\\\",\\\\\"type\\\\\":\\\\\"line\\\\\",\\\\\"params\\\\\":{\\\\\"addTooltip\\\\\":true,\\\\\"addLegend\\\\\":true,\\\\\"legendPosition\\\\\":\\\\\"right\\\\\",\\\\\"showCircles\\\\\":true,\\\\\"interpolate\\\\\":\\\\\"linear\\\\\",\\\\\"scale\\\\\":\\\\\"linear\\\\\",\\\\\"drawLinesBetweenPoints\\\\\":true,\\\\\"radiusRatio\\\\\":9,\\\\\"times\\\\\":[],\\\\\"addTimeMarker\\\\\":false,\\\\\"defaultYExtents\\\\\":false,\\\\\"setYExtents\\\\\":false},\\\\\"aggs\\\\\":[{\\\\\"id\\\\\":\\\\\"1\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"percentiles\\\\\",\\\\\"schema\\\\\":\\\\\"metric\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"app.total_time\\\\\",\\\\\"percents\\\\\":[50,90,95]}},{\\\\\"id\\\\\":\\\\\"2\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"date_histogram\\\\\",\\\\\"schema\\\\\":\\\\\"segment\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"@timestamp\\\\\",\\\\\"interval\\\\\":\\\\\"auto\\\\\",\\\\\"customInterval\\\\\":\\\\\"2h\\\\\",\\\\\"min_doc_count\\\\\":1,\\\\\"extended_bounds\\\\\":{}}},{\\\\\"id\\\\\":\\\\\"3\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"terms\\\\\",\\\\\"schema\\\\\":\\\\\"group\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"system.syslog.program\\\\\",\\\\\"size\\\\\":5,\\\\\"order\\\\\":\\\\\"desc\\\\\",\\\\\"orderBy\\\\\":\\\\\"_term\\\\\"}}],\\\\\"listeners\\\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n`,\n});\nconst testIndexPatternV6 = new opensearch.DashboardObject(\"test_index_pattern_v6\", {\n    body: `[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n`,\n});\nconst testIndexPatternV7 = new opensearch.DashboardObject(\"test_index_pattern_v7\", {\n    body: `[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest_visualization_v6 = opensearch.DashboardObject(\"testVisualizationV6\", body=\"\"\"[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_visualization_v7 = opensearch.DashboardObject(\"testVisualizationV7\", body=\"\"\"[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_index_pattern_v6 = opensearch.DashboardObject(\"testIndexPatternV6\", body=\"\"\"[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_index_pattern_v7 = opensearch.DashboardObject(\"testIndexPatternV7\", body=\"\"\"[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testVisualizationV6 = new Opensearch.DashboardObject(\"testVisualizationV6\", new Opensearch.DashboardObjectArgs\n        {\n            Body = @\"[\n  {\n    \"\"_id\"\": \"\"visualization:response-time-percentile\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"visualization\"\",\n      \"\"visualization\"\": {\n        \"\"title\"\": \"\"Total response time percentiles\"\",\n        \"\"visState\"\": \"\"{\\\"\"title\\\"\":\\\"\"Total response time percentiles\\\"\",\\\"\"type\\\"\":\\\"\"line\\\"\",\\\"\"params\\\"\":{\\\"\"addTooltip\\\"\":true,\\\"\"addLegend\\\"\":true,\\\"\"legendPosition\\\"\":\\\"\"right\\\"\",\\\"\"showCircles\\\"\":true,\\\"\"interpolate\\\"\":\\\"\"linear\\\"\",\\\"\"scale\\\"\":\\\"\"linear\\\"\",\\\"\"drawLinesBetweenPoints\\\"\":true,\\\"\"radiusRatio\\\"\":9,\\\"\"times\\\"\":[],\\\"\"addTimeMarker\\\"\":false,\\\"\"defaultYExtents\\\"\":false,\\\"\"setYExtents\\\"\":false},\\\"\"aggs\\\"\":[{\\\"\"id\\\"\":\\\"\"1\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"percentiles\\\"\",\\\"\"schema\\\"\":\\\"\"metric\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"app.total_time\\\"\",\\\"\"percents\\\"\":[50,90,95]}},{\\\"\"id\\\"\":\\\"\"2\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"date_histogram\\\"\",\\\"\"schema\\\"\":\\\"\"segment\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"@timestamp\\\"\",\\\"\"interval\\\"\":\\\"\"auto\\\"\",\\\"\"customInterval\\\"\":\\\"\"2h\\\"\",\\\"\"min_doc_count\\\"\":1,\\\"\"extended_bounds\\\"\":{}}},{\\\"\"id\\\"\":\\\"\"3\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"terms\\\"\",\\\"\"schema\\\"\":\\\"\"group\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"system.syslog.program\\\"\",\\\"\"size\\\"\":5,\\\"\"order\\\"\":\\\"\"desc\\\"\",\\\"\"orderBy\\\"\":\\\"\"_term\\\"\"}}],\\\"\"listeners\\\"\":{}}\"\",\n        \"\"uiStateJSON\"\": \"\"{}\"\",\n        \"\"description\"\": \"\"\"\",\n        \"\"version\"\": 1\n      }\n    }\n  }\n]\n\n\",\n        });\n        var testVisualizationV7 = new Opensearch.DashboardObject(\"testVisualizationV7\", new Opensearch.DashboardObjectArgs\n        {\n            Body = @\"[\n  {\n    \"\"_id\"\": \"\"response-time-percentile\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"visualization\"\",\n      \"\"visualization\"\": {\n        \"\"title\"\": \"\"Total response time percentiles\"\",\n        \"\"visState\"\": \"\"{\\\"\"title\\\"\":\\\"\"Total response time percentiles\\\"\",\\\"\"type\\\"\":\\\"\"line\\\"\",\\\"\"params\\\"\":{\\\"\"addTooltip\\\"\":true,\\\"\"addLegend\\\"\":true,\\\"\"legendPosition\\\"\":\\\"\"right\\\"\",\\\"\"showCircles\\\"\":true,\\\"\"interpolate\\\"\":\\\"\"linear\\\"\",\\\"\"scale\\\"\":\\\"\"linear\\\"\",\\\"\"drawLinesBetweenPoints\\\"\":true,\\\"\"radiusRatio\\\"\":9,\\\"\"times\\\"\":[],\\\"\"addTimeMarker\\\"\":false,\\\"\"defaultYExtents\\\"\":false,\\\"\"setYExtents\\\"\":false},\\\"\"aggs\\\"\":[{\\\"\"id\\\"\":\\\"\"1\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"percentiles\\\"\",\\\"\"schema\\\"\":\\\"\"metric\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"app.total_time\\\"\",\\\"\"percents\\\"\":[50,90,95]}},{\\\"\"id\\\"\":\\\"\"2\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"date_histogram\\\"\",\\\"\"schema\\\"\":\\\"\"segment\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"@timestamp\\\"\",\\\"\"interval\\\"\":\\\"\"auto\\\"\",\\\"\"customInterval\\\"\":\\\"\"2h\\\"\",\\\"\"min_doc_count\\\"\":1,\\\"\"extended_bounds\\\"\":{}}},{\\\"\"id\\\"\":\\\"\"3\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"terms\\\"\",\\\"\"schema\\\"\":\\\"\"group\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"system.syslog.program\\\"\",\\\"\"size\\\"\":5,\\\"\"order\\\"\":\\\"\"desc\\\"\",\\\"\"orderBy\\\"\":\\\"\"_term\\\"\"}}],\\\"\"listeners\\\"\":{}}\"\",\n        \"\"uiStateJSON\"\": \"\"{}\"\",\n        \"\"description\"\": \"\"\"\",\n        \"\"version\"\": 1\n      }\n    }\n  }\n]\n\n\",\n        });\n        var testIndexPatternV6 = new Opensearch.DashboardObject(\"testIndexPatternV6\", new Opensearch.DashboardObjectArgs\n        {\n            Body = @\"[\n  {\n    \"\"_id\"\": \"\"index-pattern:cloudwatch\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"index-pattern\"\",\n      \"\"index-pattern\"\": {\n        \"\"title\"\": \"\"cloudwatch-*\"\",\n        \"\"timeFieldName\"\": \"\"timestamp\"\"\n      }\n    }\n  }\n]\n\n\",\n        });\n        var testIndexPatternV7 = new Opensearch.DashboardObject(\"testIndexPatternV7\", new Opensearch.DashboardObjectArgs\n        {\n            Body = @\"[\n  {\n    \"\"_id\"\": \"\"index-pattern:cloudwatch\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"index-pattern\"\",\n      \"\"index-pattern\"\": {\n        \"\"title\"\": \"\"cloudwatch-*\"\",\n        \"\"timeFieldName\"\": \"\"timestamp\"\"\n      }\n    }\n  }\n]\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewDashboardObject(ctx, \"testVisualizationV6\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(\"[\\n  {\\n    \\\"_id\\\": \\\"visualization:response-time-percentile\\\",\\n    \\\"_type\\\": \\\"doc\\\",\\n    \\\"_source\\\": {\\n      \\\"type\\\": \\\"visualization\\\",\\n      \\\"visualization\\\": {\\n        \\\"title\\\": \\\"Total response time percentiles\\\",\\n        \\\"visState\\\": \\\"{\\\\\\\"title\\\\\\\":\\\\\\\"Total response time percentiles\\\\\\\",\\\\\\\"type\\\\\\\":\\\\\\\"line\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"addTooltip\\\\\\\":true,\\\\\\\"addLegend\\\\\\\":true,\\\\\\\"legendPosition\\\\\\\":\\\\\\\"right\\\\\\\",\\\\\\\"showCircles\\\\\\\":true,\\\\\\\"interpolate\\\\\\\":\\\\\\\"linear\\\\\\\",\\\\\\\"scale\\\\\\\":\\\\\\\"linear\\\\\\\",\\\\\\\"drawLinesBetweenPoints\\\\\\\":true,\\\\\\\"radiusRatio\\\\\\\":9,\\\\\\\"times\\\\\\\":[],\\\\\\\"addTimeMarker\\\\\\\":false,\\\\\\\"defaultYExtents\\\\\\\":false,\\\\\\\"setYExtents\\\\\\\":false},\\\\\\\"aggs\\\\\\\":[{\\\\\\\"id\\\\\\\":\\\\\\\"1\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"percentiles\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"metric\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"app.total_time\\\\\\\",\\\\\\\"percents\\\\\\\":[50,90,95]}},{\\\\\\\"id\\\\\\\":\\\\\\\"2\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"date_histogram\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"segment\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"@timestamp\\\\\\\",\\\\\\\"interval\\\\\\\":\\\\\\\"auto\\\\\\\",\\\\\\\"customInterval\\\\\\\":\\\\\\\"2h\\\\\\\",\\\\\\\"min_doc_count\\\\\\\":1,\\\\\\\"extended_bounds\\\\\\\":{}}},{\\\\\\\"id\\\\\\\":\\\\\\\"3\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"terms\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"group\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"system.syslog.program\\\\\\\",\\\\\\\"size\\\\\\\":5,\\\\\\\"order\\\\\\\":\\\\\\\"desc\\\\\\\",\\\\\\\"orderBy\\\\\\\":\\\\\\\"_term\\\\\\\"}}],\\\\\\\"listeners\\\\\\\":{}}\\\",\\n        \\\"uiStateJSON\\\": \\\"{}\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"version\\\": 1\\n      }\\n    }\\n  }\\n]\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testVisualizationV7\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(\"[\\n  {\\n    \\\"_id\\\": \\\"response-time-percentile\\\",\\n    \\\"_source\\\": {\\n      \\\"type\\\": \\\"visualization\\\",\\n      \\\"visualization\\\": {\\n        \\\"title\\\": \\\"Total response time percentiles\\\",\\n        \\\"visState\\\": \\\"{\\\\\\\"title\\\\\\\":\\\\\\\"Total response time percentiles\\\\\\\",\\\\\\\"type\\\\\\\":\\\\\\\"line\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"addTooltip\\\\\\\":true,\\\\\\\"addLegend\\\\\\\":true,\\\\\\\"legendPosition\\\\\\\":\\\\\\\"right\\\\\\\",\\\\\\\"showCircles\\\\\\\":true,\\\\\\\"interpolate\\\\\\\":\\\\\\\"linear\\\\\\\",\\\\\\\"scale\\\\\\\":\\\\\\\"linear\\\\\\\",\\\\\\\"drawLinesBetweenPoints\\\\\\\":true,\\\\\\\"radiusRatio\\\\\\\":9,\\\\\\\"times\\\\\\\":[],\\\\\\\"addTimeMarker\\\\\\\":false,\\\\\\\"defaultYExtents\\\\\\\":false,\\\\\\\"setYExtents\\\\\\\":false},\\\\\\\"aggs\\\\\\\":[{\\\\\\\"id\\\\\\\":\\\\\\\"1\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"percentiles\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"metric\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"app.total_time\\\\\\\",\\\\\\\"percents\\\\\\\":[50,90,95]}},{\\\\\\\"id\\\\\\\":\\\\\\\"2\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"date_histogram\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"segment\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"@timestamp\\\\\\\",\\\\\\\"interval\\\\\\\":\\\\\\\"auto\\\\\\\",\\\\\\\"customInterval\\\\\\\":\\\\\\\"2h\\\\\\\",\\\\\\\"min_doc_count\\\\\\\":1,\\\\\\\"extended_bounds\\\\\\\":{}}},{\\\\\\\"id\\\\\\\":\\\\\\\"3\\\\\\\",\\\\\\\"enabled\\\\\\\":true,\\\\\\\"type\\\\\\\":\\\\\\\"terms\\\\\\\",\\\\\\\"schema\\\\\\\":\\\\\\\"group\\\\\\\",\\\\\\\"params\\\\\\\":{\\\\\\\"field\\\\\\\":\\\\\\\"system.syslog.program\\\\\\\",\\\\\\\"size\\\\\\\":5,\\\\\\\"order\\\\\\\":\\\\\\\"desc\\\\\\\",\\\\\\\"orderBy\\\\\\\":\\\\\\\"_term\\\\\\\"}}],\\\\\\\"listeners\\\\\\\":{}}\\\",\\n        \\\"uiStateJSON\\\": \\\"{}\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"version\\\": 1\\n      }\\n    }\\n  }\\n]\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testIndexPatternV6\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(\"[\\n  {\\n    \\\"_id\\\": \\\"index-pattern:cloudwatch\\\",\\n    \\\"_type\\\": \\\"doc\\\",\\n    \\\"_source\\\": {\\n      \\\"type\\\": \\\"index-pattern\\\",\\n      \\\"index-pattern\\\": {\\n        \\\"title\\\": \\\"cloudwatch-*\\\",\\n        \\\"timeFieldName\\\": \\\"timestamp\\\"\\n      }\\n    }\\n  }\\n]\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testIndexPatternV7\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(\"[\\n  {\\n    \\\"_id\\\": \\\"index-pattern:cloudwatch\\\",\\n    \\\"_type\\\": \\\"doc\\\",\\n    \\\"_source\\\": {\\n      \\\"type\\\": \\\"index-pattern\\\",\\n      \\\"index-pattern\\\": {\\n        \\\"title\\\": \\\"cloudwatch-*\\\",\\n        \\\"timeFieldName\\\": \\\"timestamp\\\"\\n      }\\n    }\\n  }\\n]\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.DashboardObject;\nimport com.pulumi.opensearch.DashboardObjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testVisualizationV6 = new DashboardObject(\"testVisualizationV6\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testVisualizationV7 = new DashboardObject(\"testVisualizationV7\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testIndexPatternV6 = new DashboardObject(\"testIndexPatternV6\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testIndexPatternV7 = new DashboardObject(\"testIndexPatternV7\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testVisualizationV6:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"visualization:response-time-percentile\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"visualization\",\n              \"visualization\": {\n                \"title\": \"Total response time percentiles\",\n                \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n                \"uiStateJSON\": \"{}\",\n                \"description\": \"\",\n                \"version\": 1\n              }\n            }\n          }\n        ]\n\n  testVisualizationV7:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"response-time-percentile\",\n            \"_source\": {\n              \"type\": \"visualization\",\n              \"visualization\": {\n                \"title\": \"Total response time percentiles\",\n                \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n                \"uiStateJSON\": \"{}\",\n                \"description\": \"\",\n                \"version\": 1\n              }\n            }\n          }\n        ]\n\n  testIndexPatternV6:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"index-pattern:cloudwatch\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"index-pattern\",\n              \"index-pattern\": {\n                \"title\": \"cloudwatch-*\",\n                \"timeFieldName\": \"timestamp\"\n              }\n            }\n          }\n        ]\n\n  testIndexPatternV7:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"index-pattern:cloudwatch\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"index-pattern\",\n              \"index-pattern\": {\n                \"title\": \"cloudwatch-*\",\n                \"timeFieldName\": \"timestamp\"\n              }\n            }\n          }\n        ]\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the dashboard object.\n"
                },
                "index": {
                    "type": "string",
                    "description": "The name of the index where dashboard data is stored.\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the dashboard object.\n"
                },
                "index": {
                    "type": "string",
                    "description": "The name of the index where dashboard data is stored.\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DashboardObject resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the dashboard object.\n"
                    },
                    "index": {
                        "type": "string",
                        "description": "The name of the index where dashboard data is stored.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dashboardTenant:DashboardTenant": {
            "description": "Provides an OpenSearch dashboard tenant resource. Please refer to the OpenSearch documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a tenant\nconst test = new opensearch.DashboardTenant(\"test\", {\n    description: \"test tenant\",\n    tenantName: \"test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a tenant\ntest = opensearch.DashboardTenant(\"test\",\n    description=\"test tenant\",\n    tenant_name=\"test\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a tenant\n        var test = new Opensearch.DashboardTenant(\"test\", new Opensearch.DashboardTenantArgs\n        {\n            Description = \"test tenant\",\n            TenantName = \"test\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewDashboardTenant(ctx, \"test\", \u0026opensearch.DashboardTenantArgs{\n\t\t\tDescription: pulumi.String(\"test tenant\"),\n\t\t\tTenantName:  pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.DashboardTenant;\nimport com.pulumi.opensearch.DashboardTenantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DashboardTenant(\"test\", DashboardTenantArgs.builder()        \n            .description(\"test tenant\")\n            .tenantName(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a tenant\n  test:\n    type: opensearch:DashboardTenant\n    properties:\n      description: test tenant\n      tenantName: test\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/dashboardTenant:DashboardTenant writer test\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the tenant.\n"
                },
                "index": {
                    "type": "string"
                },
                "tenantName": {
                    "type": "string",
                    "description": "The name of the tenant.\n"
                }
            },
            "required": [
                "index",
                "tenantName"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the tenant.\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "The name of the tenant.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "tenantName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DashboardTenant resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the tenant.\n"
                    },
                    "index": {
                        "type": "string"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "The name of the tenant.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dataStream:DataStream": {
            "description": "A data stream lets you store append-only time series data across multiple (hidden, auto-generated) indices while giving you a single named resource for requests\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst fooComposableIndexTemplate = new opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", {body: `{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n`});\nconst fooDataStream = new opensearch.DataStream(\"fooDataStream\", {}, {\n    dependsOn: [fooComposableIndexTemplate],\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\nfoo_composable_index_template = opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", body=\"\"\"{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n\"\"\")\nfoo_data_stream = opensearch.DataStream(\"fooDataStream\", opts=pulumi.ResourceOptions(depends_on=[foo_composable_index_template]))\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var fooComposableIndexTemplate = new Opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", new Opensearch.ComposableIndexTemplateArgs\n        {\n            Body = @\"{\n  \"\"index_patterns\"\": [\"\"foo-data-stream*\"\"],\n  \"\"data_stream\"\": {}\n}\n\",\n        });\n        var fooDataStream = new Opensearch.DataStream(\"fooDataStream\", new Opensearch.DataStreamArgs\n        {\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                fooComposableIndexTemplate,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfooComposableIndexTemplate, err := opensearch.NewComposableIndexTemplate(ctx, \"fooComposableIndexTemplate\", \u0026opensearch.ComposableIndexTemplateArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"index_patterns\\\": [\\\"foo-data-stream*\\\"],\\n  \\\"data_stream\\\": {}\\n}\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDataStream(ctx, \"fooDataStream\", nil, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tfooComposableIndexTemplate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComposableIndexTemplate;\nimport com.pulumi.opensearch.ComposableIndexTemplateArgs;\nimport com.pulumi.opensearch.DataStream;\nimport com.pulumi.opensearch.DataStreamArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fooComposableIndexTemplate = new ComposableIndexTemplate(\"fooComposableIndexTemplate\", ComposableIndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n            \"\"\")\n            .build());\n\n        var fooDataStream = new DataStream(\"fooDataStream\", DataStreamArgs.Empty, CustomResourceOptions.builder()\n            .dependsOn(fooComposableIndexTemplate)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fooComposableIndexTemplate:\n    type: opensearch:ComposableIndexTemplate\n    properties:\n      body: |\n        {\n          \"index_patterns\": [\"foo-data-stream*\"],\n          \"data_stream\": {}\n        }\n  fooDataStream:\n    type: opensearch:DataStream\n    options:\n      dependson:\n        - ${fooComposableIndexTemplate}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create, must have a matching\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create, must have a matching\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DataStream resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the data stream to create, must have a matching\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/destination:Destination": {
            "description": "Provides an OpenSearch destination, a reusable communication channel for an action, such as email, Slack, or a webhook URL. Please refer to the OpenSearch destination documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst testDestination = new opensearch.Destination(\"test_destination\", {\n    body: `{\n  \"name\": \"my-destination\",\n  \"type\": \"slack\",\n  \"slack\": {\n    \"url\": \"http://www.example.com\"\n  }\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest_destination = opensearch.Destination(\"testDestination\", body=\"\"\"{\n  \"name\": \"my-destination\",\n  \"type\": \"slack\",\n  \"slack\": {\n    \"url\": \"http://www.example.com\"\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testDestination = new Opensearch.Destination(\"testDestination\", new Opensearch.DestinationArgs\n        {\n            Body = @\"{\n  \"\"name\"\": \"\"my-destination\"\",\n  \"\"type\"\": \"\"slack\"\",\n  \"\"slack\"\": {\n    \"\"url\"\": \"\"http://www.example.com\"\"\n  }\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewDestination(ctx, \"testDestination\", \u0026opensearch.DestinationArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"name\\\": \\\"my-destination\\\",\\n  \\\"type\\\": \\\"slack\\\",\\n  \\\"slack\\\": {\\n    \\\"url\\\": \\\"http://www.example.com\\\"\\n  }\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Destination;\nimport com.pulumi.opensearch.DestinationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDestination = new Destination(\"testDestination\", DestinationArgs.builder()        \n            .body(\"\"\"\n{\n  \"name\": \"my-destination\",\n  \"type\": \"slack\",\n  \"slack\": {\n    \"url\": \"http://www.example.com\"\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDestination:\n    type: opensearch:Destination\n    properties:\n      body: |+\n        {\n          \"name\": \"my-destination\",\n          \"type\": \"slack\",\n          \"slack\": {\n            \"url\": \"http://www.example.com\"\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# Import by name\n\n```sh\n $ pulumi import opensearch:index/destination:Destination test_destination my-destination\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the destination.\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the destination.\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Destination resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the destination.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/index:Index": {
            "description": "Provides an OpenSearch index resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a simple index\nconst test = new opensearch.Index(\"test\", {\n    mappings: `{\n  \"people\": {\n    \"_all\": {\n      \"enabled\": false\n    },\n    \"properties\": {\n      \"email\": {\n        \"type\": \"text\"\n      }\n    }\n  }\n}\n`,\n    numberOfReplicas: \"1\",\n    numberOfShards: \"1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a simple index\ntest = opensearch.Index(\"test\",\n    mappings=\"\"\"{\n  \"people\": {\n    \"_all\": {\n      \"enabled\": false\n    },\n    \"properties\": {\n      \"email\": {\n        \"type\": \"text\"\n      }\n    }\n  }\n}\n\n\"\"\",\n    number_of_replicas=\"1\",\n    number_of_shards=\"1\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a simple index\n        var test = new Opensearch.Index(\"test\", new Opensearch.IndexArgs\n        {\n            Mappings = @\"{\n  \"\"people\"\": {\n    \"\"_all\"\": {\n      \"\"enabled\"\": false\n    },\n    \"\"properties\"\": {\n      \"\"email\"\": {\n        \"\"type\"\": \"\"text\"\"\n      }\n    }\n  }\n}\n\n\",\n            NumberOfReplicas = \"1\",\n            NumberOfShards = \"1\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIndex(ctx, \"test\", \u0026opensearch.IndexArgs{\n\t\t\tMappings:         pulumi.String(\"{\\n  \\\"people\\\": {\\n    \\\"_all\\\": {\\n      \\\"enabled\\\": false\\n    },\\n    \\\"properties\\\": {\\n      \\\"email\\\": {\\n        \\\"type\\\": \\\"text\\\"\\n      }\\n    }\\n  }\\n}\\n\\n\"),\n\t\t\tNumberOfReplicas: pulumi.String(\"1\"),\n\t\t\tNumberOfShards:   pulumi.String(\"1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Index;\nimport com.pulumi.opensearch.IndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Index(\"test\", IndexArgs.builder()        \n            .mappings(\"\"\"\n{\n  \"people\": {\n    \"_all\": {\n      \"enabled\": false\n    },\n    \"properties\": {\n      \"email\": {\n        \"type\": \"text\"\n      }\n    }\n  }\n}\n\n            \"\"\")\n            .numberOfReplicas(1)\n            .numberOfShards(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a simple index\n  test:\n    type: opensearch:Index\n    properties:\n      mappings: |+\n        {\n          \"people\": {\n            \"_all\": {\n              \"enabled\": false\n            },\n            \"properties\": {\n              \"email\": {\n                \"type\": \"text\"\n              }\n            }\n          }\n        }\n\n      numberOfReplicas: 1\n      numberOfShards: 1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# Import by name\n\n```sh\n $ pulumi import opensearch:index/index:Index test terraform-test\n```\n\n ",
            "properties": {
                "aliases": {
                    "type": "string",
                    "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs\nautomatically converting the alias name to the actual index name. An alias can also be mapped to more than one index,\nand when specifying it, the alias will automatically expand to the aliased indices.\n"
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n"
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n"
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n"
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n"
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n"
                },
                "analyzeMaxTokenCount": {
                    "type": "string",
                    "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or\nuse all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses\nDEFLATE for a higher compression ratio. This can be set only on creation.\n"
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the\npipeline does not exist.\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "string",
                    "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                },
                "includeTypeName": {
                    "type": "string",
                    "description": "A string that indicates if and what we should pass to include_type_name parameter. Set to `\"false\"` when trying to\ncreate an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster\nwith a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                },
                "indexSimilarityDefault": {
                    "type": "string",
                    "description": "A JSON string describing the default index similarity config.\n"
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the\nsource entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is\nreformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n"
                },
                "mappings": {
                    "type": "string",
                    "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the\ncomplexities of field mapping updates, updates of this field are not allowed via this provider.\n"
                },
                "maxDocvalueFieldsSearch": {
                    "type": "string",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxInnerResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified\nnumber.\n"
                },
                "maxNgramDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between min_gram and max_gram for NGramTokenizer and NGramTokenFilter. A stringified\nnumber.\n"
                },
                "maxRefreshListeners": {
                    "type": "string",
                    "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                },
                "maxRegexLength": {
                    "type": "string",
                    "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                },
                "maxRescoreWindow": {
                    "type": "string",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                },
                "maxResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                },
                "maxScriptFields": {
                    "type": "string",
                    "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxShingleDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between max_shingle_size and min_shingle_size for ShingleTokenFilter. A stringified\nnumber.\n"
                },
                "maxTermsCount": {
                    "type": "string",
                    "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index to create\n"
                },
                "numberOfReplicas": {
                    "type": "string",
                    "description": "Number of shard replicas. A stringified number.\n"
                },
                "numberOfRoutingShards": {
                    "type": "string",
                    "description": "Value used with number_of_shards to route documents to a primary shard. A stringified number. This can be set only on\ncreation.\n"
                },
                "numberOfShards": {
                    "type": "string",
                    "description": "Number of shards for the index. This can be set only on creation.\n"
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1`\nto disable refresh.\n"
                },
                "rolloverAlias": {
                    "type": "string"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "string",
                    "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n"
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until it’s considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the\nshard from being opened. Accepts `false`, `true`, `checksum`.\n"
                },
                "sortField": {
                    "type": "string",
                    "description": "The field to sort shards in this index by.\n"
                },
                "sortOrder": {
                    "type": "string",
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n"
                }
            },
            "required": [
                "name",
                "numberOfShards",
                "rolloverAlias"
            ],
            "inputProperties": {
                "aliases": {
                    "type": "string",
                    "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs\nautomatically converting the alias name to the actual index name. An alias can also be mapped to more than one index,\nand when specifying it, the alias will automatically expand to the aliased indices.\n",
                    "willReplaceOnChanges": true
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analyzeMaxTokenCount": {
                    "type": "string",
                    "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or\nuse all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses\nDEFLATE for a higher compression ratio. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the\npipeline does not exist.\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "string",
                    "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                },
                "includeTypeName": {
                    "type": "string",
                    "description": "A string that indicates if and what we should pass to include_type_name parameter. Set to `\"false\"` when trying to\ncreate an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster\nwith a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                },
                "indexSimilarityDefault": {
                    "type": "string",
                    "description": "A JSON string describing the default index similarity config.\n",
                    "willReplaceOnChanges": true
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the\nsource entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is\nreformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "mappings": {
                    "type": "string",
                    "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the\ncomplexities of field mapping updates, updates of this field are not allowed via this provider.\n",
                    "willReplaceOnChanges": true
                },
                "maxDocvalueFieldsSearch": {
                    "type": "string",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxInnerResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified\nnumber.\n"
                },
                "maxNgramDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between min_gram and max_gram for NGramTokenizer and NGramTokenFilter. A stringified\nnumber.\n"
                },
                "maxRefreshListeners": {
                    "type": "string",
                    "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                },
                "maxRegexLength": {
                    "type": "string",
                    "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                },
                "maxRescoreWindow": {
                    "type": "string",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                },
                "maxResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                },
                "maxScriptFields": {
                    "type": "string",
                    "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxShingleDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between max_shingle_size and min_shingle_size for ShingleTokenFilter. A stringified\nnumber.\n"
                },
                "maxTermsCount": {
                    "type": "string",
                    "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index to create\n",
                    "willReplaceOnChanges": true
                },
                "numberOfReplicas": {
                    "type": "string",
                    "description": "Number of shard replicas. A stringified number.\n"
                },
                "numberOfRoutingShards": {
                    "type": "string",
                    "description": "Value used with number_of_shards to route documents to a primary shard. A stringified number. This can be set only on\ncreation.\n",
                    "willReplaceOnChanges": true
                },
                "numberOfShards": {
                    "type": "string",
                    "description": "Number of shards for the index. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1`\nto disable refresh.\n"
                },
                "rolloverAlias": {
                    "type": "string"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "string",
                    "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until it’s considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the\nshard from being opened. Accepts `false`, `true`, `checksum`.\n",
                    "willReplaceOnChanges": true
                },
                "sortField": {
                    "type": "string",
                    "description": "The field to sort shards in this index by.\n",
                    "willReplaceOnChanges": true
                },
                "sortOrder": {
                    "type": "string",
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Index resources.\n",
                "properties": {
                    "aliases": {
                        "type": "string",
                        "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs\nautomatically converting the alias name to the actual index name. An alias can also be mapped to more than one index,\nand when specifying it, the alias will automatically expand to the aliased indices.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisAnalyzer": {
                        "type": "string",
                        "description": "A JSON string describing the analyzers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisCharFilter": {
                        "type": "string",
                        "description": "A JSON string describing the char_filters applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisFilter": {
                        "type": "string",
                        "description": "A JSON string describing the filters applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisNormalizer": {
                        "type": "string",
                        "description": "A JSON string describing the normalizers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisTokenizer": {
                        "type": "string",
                        "description": "A JSON string describing the tokenizers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analyzeMaxTokenCount": {
                        "type": "string",
                        "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                    },
                    "autoExpandReplicas": {
                        "type": "string",
                        "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or\nuse all for the upper bound (e.g. 0-all)\n"
                    },
                    "blocksMetadata": {
                        "type": "boolean",
                        "description": "Set to `true` to disable index metadata reads and writes.\n"
                    },
                    "blocksRead": {
                        "type": "boolean",
                        "description": "Set to `true` to disable read operations against the index.\n"
                    },
                    "blocksReadOnly": {
                        "type": "boolean",
                        "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                    },
                    "blocksReadOnlyAllowDelete": {
                        "type": "boolean",
                        "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                    },
                    "blocksWrite": {
                        "type": "boolean",
                        "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                    },
                    "codec": {
                        "type": "string",
                        "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses\nDEFLATE for a higher compression ratio. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultPipeline": {
                        "type": "string",
                        "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the\npipeline does not exist.\n"
                    },
                    "forceDestroy": {
                        "type": "boolean",
                        "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                    },
                    "gcDeletes": {
                        "type": "string",
                        "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                    },
                    "highlightMaxAnalyzedOffset": {
                        "type": "string",
                        "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                    },
                    "includeTypeName": {
                        "type": "string",
                        "description": "A string that indicates if and what we should pass to include_type_name parameter. Set to `\"false\"` when trying to\ncreate an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster\nwith a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                    },
                    "indexSimilarityDefault": {
                        "type": "string",
                        "description": "A JSON string describing the default index similarity config.\n",
                        "willReplaceOnChanges": true
                    },
                    "indexingSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "indexingSlowlogSource": {
                        "type": "string",
                        "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the\nsource entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is\nreformatted by default to make sure that it fits on a single log line.\n"
                    },
                    "indexingSlowlogThresholdIndexDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                    },
                    "indexingSlowlogThresholdIndexInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                    },
                    "indexingSlowlogThresholdIndexTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                    },
                    "indexingSlowlogThresholdIndexWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                    },
                    "loadFixedBitsetFiltersEagerly": {
                        "type": "boolean",
                        "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "mappings": {
                        "type": "string",
                        "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the\ncomplexities of field mapping updates, updates of this field are not allowed via this provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxDocvalueFieldsSearch": {
                        "type": "string",
                        "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                    },
                    "maxInnerResultWindow": {
                        "type": "string",
                        "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified\nnumber.\n"
                    },
                    "maxNgramDiff": {
                        "type": "string",
                        "description": "The maximum allowed difference between min_gram and max_gram for NGramTokenizer and NGramTokenFilter. A stringified\nnumber.\n"
                    },
                    "maxRefreshListeners": {
                        "type": "string",
                        "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                    },
                    "maxRegexLength": {
                        "type": "string",
                        "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                    },
                    "maxRescoreWindow": {
                        "type": "string",
                        "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                    },
                    "maxResultWindow": {
                        "type": "string",
                        "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                    },
                    "maxScriptFields": {
                        "type": "string",
                        "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                    },
                    "maxShingleDiff": {
                        "type": "string",
                        "description": "The maximum allowed difference between max_shingle_size and min_shingle_size for ShingleTokenFilter. A stringified\nnumber.\n"
                    },
                    "maxTermsCount": {
                        "type": "string",
                        "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index to create\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfReplicas": {
                        "type": "string",
                        "description": "Number of shard replicas. A stringified number.\n"
                    },
                    "numberOfRoutingShards": {
                        "type": "string",
                        "description": "Value used with number_of_shards to route documents to a primary shard. A stringified number. This can be set only on\ncreation.\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfShards": {
                        "type": "string",
                        "description": "Number of shards for the index. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "refreshInterval": {
                        "type": "string",
                        "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1`\nto disable refresh.\n"
                    },
                    "rolloverAlias": {
                        "type": "string"
                    },
                    "routingAllocationEnable": {
                        "type": "string",
                        "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                    },
                    "routingPartitionSize": {
                        "type": "string",
                        "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "routingRebalanceEnable": {
                        "type": "string",
                        "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                    },
                    "searchIdleAfter": {
                        "type": "string",
                        "description": "How long a shard can not receive a search or get request until it’s considered search idle.\n"
                    },
                    "searchSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "searchSlowlogThresholdFetchDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdFetchInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdFetchTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdFetchWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                    },
                    "searchSlowlogThresholdQueryDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdQueryInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdQueryTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdQueryWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                    },
                    "shardCheckOnStartup": {
                        "type": "string",
                        "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the\nshard from being opened. Accepts `false`, `true`, `checksum`.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortField": {
                        "type": "string",
                        "description": "The field to sort shards in this index by.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortOrder": {
                        "type": "string",
                        "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/indexTemplate:IndexTemplate": {
            "description": "Provides an Opensearch index template resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create an index template\nconst template1 = new opensearch.IndexTemplate(\"template_1\", {\n    body: `{\n  \"template\": \"te*\",\n  \"settings\": {\n    \"number_of_shards\": 1\n  },\n  \"mappings\": {\n    \"type1\": {\n      \"_source\": {\n        \"enabled\": false\n      },\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z YYYY\"\n        }\n      }\n    }\n  }\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create an index template\ntemplate1 = opensearch.IndexTemplate(\"template1\", body=\"\"\"{\n  \"template\": \"te*\",\n  \"settings\": {\n    \"number_of_shards\": 1\n  },\n  \"mappings\": {\n    \"type1\": {\n      \"_source\": {\n        \"enabled\": false\n      },\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z YYYY\"\n        }\n      }\n    }\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create an index template\n        var template1 = new Opensearch.IndexTemplate(\"template1\", new Opensearch.IndexTemplateArgs\n        {\n            Body = @\"{\n  \"\"template\"\": \"\"te*\"\",\n  \"\"settings\"\": {\n    \"\"number_of_shards\"\": 1\n  },\n  \"\"mappings\"\": {\n    \"\"type1\"\": {\n      \"\"_source\"\": {\n        \"\"enabled\"\": false\n      },\n      \"\"properties\"\": {\n        \"\"host_name\"\": {\n          \"\"type\"\": \"\"keyword\"\"\n        },\n        \"\"created_at\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"EEE MMM dd HH:mm:ss Z YYYY\"\"\n        }\n      }\n    }\n  }\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIndexTemplate(ctx, \"template1\", \u0026opensearch.IndexTemplateArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"template\\\": \\\"te*\\\",\\n  \\\"settings\\\": {\\n    \\\"number_of_shards\\\": 1\\n  },\\n  \\\"mappings\\\": {\\n    \\\"type1\\\": {\\n      \\\"_source\\\": {\\n        \\\"enabled\\\": false\\n      },\\n      \\\"properties\\\": {\\n        \\\"host_name\\\": {\\n          \\\"type\\\": \\\"keyword\\\"\\n        },\\n        \\\"created_at\\\": {\\n          \\\"type\\\": \\\"date\\\",\\n          \\\"format\\\": \\\"EEE MMM dd HH:mm:ss Z YYYY\\\"\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IndexTemplate;\nimport com.pulumi.opensearch.IndexTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var template1 = new IndexTemplate(\"template1\", IndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"template\": \"te*\",\n  \"settings\": {\n    \"number_of_shards\": 1\n  },\n  \"mappings\": {\n    \"type1\": {\n      \"_source\": {\n        \"enabled\": false\n      },\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z YYYY\"\n        }\n      }\n    }\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an index template\n  template1:\n    type: opensearch:IndexTemplate\n    properties:\n      body: |+\n        {\n          \"template\": \"te*\",\n          \"settings\": {\n            \"number_of_shards\": 1\n          },\n          \"mappings\": {\n            \"type1\": {\n              \"_source\": {\n                \"enabled\": false\n              },\n              \"properties\": {\n                \"host_name\": {\n                  \"type\": \"keyword\"\n                },\n                \"created_at\": {\n                  \"type\": \"date\",\n                  \"format\": \"EEE MMM dd HH:mm:ss Z YYYY\"\n                }\n              }\n            }\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/indexTemplate:IndexTemplate template_1 template_1\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IndexTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the index template.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ingestPipeline:IngestPipeline": {
            "description": "Provides an Opensearch ingest pipeline resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a simple ingest pipeline\nconst test = new opensearch.IngestPipeline(\"test\", {\n    body: `{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a simple ingest pipeline\ntest = opensearch.IngestPipeline(\"test\", body=\"\"\"{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a simple ingest pipeline\n        var test = new Opensearch.IngestPipeline(\"test\", new Opensearch.IngestPipelineArgs\n        {\n            Body = @\"{\n  \"\"description\"\" : \"\"describe pipeline\"\",\n  \"\"version\"\": 123,\n  \"\"processors\"\" : [\n    {\n      \"\"set\"\" : {\n        \"\"field\"\": \"\"foo\"\",\n        \"\"value\"\": \"\"bar\"\"\n      }\n    }\n  ]\n}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIngestPipeline(ctx, \"test\", \u0026opensearch.IngestPipelineArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"description\\\" : \\\"describe pipeline\\\",\\n  \\\"version\\\": 123,\\n  \\\"processors\\\" : [\\n    {\\n      \\\"set\\\" : {\\n        \\\"field\\\": \\\"foo\\\",\\n        \\\"value\\\": \\\"bar\\\"\\n      }\\n    }\\n  ]\\n}\\n\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IngestPipeline;\nimport com.pulumi.opensearch.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new IngestPipeline(\"test\", IngestPipelineArgs.builder()        \n            .body(\"\"\"\n{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a simple ingest pipeline\n  test:\n    type: opensearch:IngestPipeline\n    properties:\n      body: |+\n        {\n          \"description\" : \"describe pipeline\",\n          \"version\": 123,\n          \"processors\" : [\n            {\n              \"set\" : {\n                \"field\": \"foo\",\n                \"value\": \"bar\"\n              }\n            }\n          ]\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/ingestPipeline:IngestPipeline test terraform-test\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the ingest pipeline\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the ingest pipeline\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IngestPipeline resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the ingest pipeline\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ingest pipeline\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ismPolicy:IsmPolicy": {
            "description": "Provides an OpenSearch Index State Management (ISM) policy. Please refer to the OpenSearch ISM documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create an ISM policy\nconst cleanup = new opensearch.IsmPolicy(\"cleanup\", {\n    policyId: \"delete_after_15d\",\n    body: fs.readFileSync(`${path.module}/policies/delete_after_15d.json`),\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create an ISM policy\ncleanup = opensearch.IsmPolicy(\"cleanup\",\n    policy_id=\"delete_after_15d\",\n    body=(lambda path: open(path).read())(f\"{path['module']}/policies/delete_after_15d.json\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create an ISM policy\n        var cleanup = new Opensearch.IsmPolicy(\"cleanup\", new Opensearch.IsmPolicyArgs\n        {\n            PolicyId = \"delete_after_15d\",\n            Body = File.ReadAllText($\"{path.Module}/policies/delete_after_15d.json\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIsmPolicy(ctx, \"cleanup\", \u0026opensearch.IsmPolicyArgs{\n\t\t\tPolicyId: pulumi.String(\"delete_after_15d\"),\n\t\t\tBody:     readFileOrPanic(fmt.Sprintf(\"%v/policies/delete_after_15d.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IsmPolicy;\nimport com.pulumi.opensearch.IsmPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cleanup = new IsmPolicy(\"cleanup\", IsmPolicyArgs.builder()        \n            .policyId(\"delete_after_15d\")\n            .body(Files.readString(Paths.get(String.format(\"%s/policies/delete_after_15d.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/ismPolicy:IsmPolicy cleanup delete_after_15d\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The id of the ISM policy.\n"
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the ISM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the ISM policy version.\n"
                }
            },
            "required": [
                "body",
                "policyId",
                "primaryTerm",
                "seqNo"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The id of the ISM policy.\n",
                    "willReplaceOnChanges": true
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the ISM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the ISM policy version.\n"
                }
            },
            "requiredInputs": [
                "body",
                "policyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IsmPolicy resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The policy document.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The id of the ISM policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "primaryTerm": {
                        "type": "integer",
                        "description": "The primary term of the ISM policy version.\n"
                    },
                    "seqNo": {
                        "type": "integer",
                        "description": "The sequence number of the ISM policy version.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ismPolicyMapping:IsmPolicyMapping": {
            "description": "Provides an OpenSearch Index State Management (ISM) policy. Please refer to the OpenSearch ISM documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = new opensearch.IsmPolicyMapping(\"test\", {\n    indexes: \"test_index\",\n    policyId: \"policy_1\",\n    state: \"delete\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.IsmPolicyMapping(\"test\",\n    indexes=\"test_index\",\n    policy_id=\"policy_1\",\n    state=\"delete\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Opensearch.IsmPolicyMapping(\"test\", new Opensearch.IsmPolicyMappingArgs\n        {\n            Indexes = \"test_index\",\n            PolicyId = \"policy_1\",\n            State = \"delete\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIsmPolicyMapping(ctx, \"test\", \u0026opensearch.IsmPolicyMappingArgs{\n\t\t\tIndexes:  pulumi.String(\"test_index\"),\n\t\t\tPolicyId: pulumi.String(\"policy_1\"),\n\t\t\tState:    pulumi.String(\"delete\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IsmPolicyMapping;\nimport com.pulumi.opensearch.IsmPolicyMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new IsmPolicyMapping(\"test\", IsmPolicyMappingArgs.builder()        \n            .indexes(\"test_index\")\n            .policyId(\"policy_1\")\n            .state(\"delete\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:IsmPolicyMapping\n    properties:\n      indexes: test_index\n      policyId: policy_1\n      state: delete\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# Import by poilcy_id\n\n```sh\n $ pulumi import opensearch:index/ismPolicyMapping:IsmPolicyMapping test policy_1\n```\n\n ",
            "properties": {
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The\nbackground process only applies the change if the index is currently in the state specified.\n"
                },
                "indexes": {
                    "type": "string",
                    "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                },
                "isSafe": {
                    "type": "boolean"
                },
                "managedIndexes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "state": {
                    "type": "string",
                    "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                }
            },
            "required": [
                "indexes",
                "managedIndexes",
                "policyId"
            ],
            "inputProperties": {
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The\nbackground process only applies the change if the index is currently in the state specified.\n"
                },
                "indexes": {
                    "type": "string",
                    "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                },
                "isSafe": {
                    "type": "boolean"
                },
                "managedIndexes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "state": {
                    "type": "string",
                    "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                }
            },
            "requiredInputs": [
                "indexes",
                "policyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IsmPolicyMapping resources.\n",
                "properties": {
                    "includes": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The\nbackground process only applies the change if the index is currently in the state specified.\n"
                    },
                    "indexes": {
                        "type": "string",
                        "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                    },
                    "isSafe": {
                        "type": "boolean"
                    },
                    "managedIndexes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The name of the policy.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/monitor:Monitor": {
            "description": "Provides an OpenSearch monitor. Please refer to the OpenSearch monitor documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst moviesLastHour = new opensearch.Monitor(\"movies_last_hour\", {\n    body: pulumi.interpolate`{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"${opensearch_destination_slack_on_call_channel.id}\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\nmovies_last_hour = opensearch.Monitor(\"moviesLastHour\", body=f\"\"\"{{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {{\n    \"period\": {{\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }}\n  }},\n  \"inputs\": [{{\n    \"search\": {{\n      \"indices\": [\"movies\"],\n      \"query\": {{\n        \"size\": 0,\n        \"aggregations\": {{}},\n        \"query\": {{\n          \"bool\": {{\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{{\n              \"range\": {{\n                \"@timestamp\": {{\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }}\n              }}\n            }}]\n          }}\n        }}\n      }}\n    }}\n  }}],\n  \"triggers\": [\n    {{\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {{\n        \"script\" : {{\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }}\n      }},\n      \"actions\" : [\n        {{\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"{opensearch_destination[\"slack_on_call_channel\"][\"id\"]}\",\n          \"message_template\" : {{\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          }},\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {{\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }}\n        }}\n      ]\n    }}\n  ]\n}}\n\n\"\"\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var moviesLastHour = new Opensearch.Monitor(\"moviesLastHour\", new Opensearch.MonitorArgs\n        {\n            Body = @$\"{{\n  \"\"name\"\": \"\"test-monitor\"\",\n  \"\"type\"\": \"\"monitor\"\",\n  \"\"enabled\"\": true,\n  \"\"schedule\"\": {{\n    \"\"period\"\": {{\n      \"\"interval\"\": 1,\n      \"\"unit\"\": \"\"MINUTES\"\"\n    }}\n  }},\n  \"\"inputs\"\": [{{\n    \"\"search\"\": {{\n      \"\"indices\"\": [\"\"movies\"\"],\n      \"\"query\"\": {{\n        \"\"size\"\": 0,\n        \"\"aggregations\"\": {{}},\n        \"\"query\"\": {{\n          \"\"bool\"\": {{\n            \"\"adjust_pure_negative\"\":true,\n            \"\"boost\"\":1,\n            \"\"filter\"\": [{{\n              \"\"range\"\": {{\n                \"\"@timestamp\"\": {{\n                  \"\"boost\"\":1,\n                  \"\"from\"\":\"\"||-1h\"\",\n                  \"\"to\"\":\"\"\"\",\n                  \"\"include_lower\"\":true,\n                  \"\"include_upper\"\":true,\n                  \"\"format\"\": \"\"epoch_millis\"\"\n                }}\n              }}\n            }}]\n          }}\n        }}\n      }}\n    }}\n  }}],\n  \"\"triggers\"\": [\n    {{\n      \"\"name\"\" : \"\"Errors\"\",\n      \"\"severity\"\" : \"\"1\"\",\n      \"\"condition\"\" : {{\n        \"\"script\"\" : {{\n          \"\"source\"\" : \"\"ctx.results[0].hits.total.value \u003e 0\"\",\n          \"\"lang\"\" : \"\"painless\"\"\n        }}\n      }},\n      \"\"actions\"\" : [\n        {{\n          \"\"name\"\" : \"\"Slack\"\",\n          \"\"destination_id\"\" : \"\"{opensearch_destination.Slack_on_call_channel.Id}\"\",\n          \"\"message_template\"\" : {{\n            \"\"source\"\" : \"\"bogus\"\",\n            \"\"lang\"\" : \"\"mustache\"\"\n          }},\n          \"\"throttle_enabled\"\" : false,\n          \"\"subject_template\"\" : {{\n            \"\"source\"\" : \"\"Production Errors\"\",\n            \"\"lang\"\" : \"\"mustache\"\"\n          }}\n        }}\n      ]\n    }}\n  ]\n}}\n\n\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewMonitor(ctx, \"moviesLastHour\", \u0026opensearch.MonitorArgs{\n\t\t\tBody: pulumi.String(fmt.Sprintf(`{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"%v\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n`, opensearch_destination.Slack_on_call_channel.Id)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Monitor;\nimport com.pulumi.opensearch.MonitorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var moviesLastHour = new Monitor(\"moviesLastHour\", MonitorArgs.builder()        \n            .body(\"\"\"\n{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"%s\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n\", opensearch_destination.slack_on_call_channel().id()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  moviesLastHour:\n    type: opensearch:Monitor\n    properties:\n      body: |+\n        {\n          \"name\": \"test-monitor\",\n          \"type\": \"monitor\",\n          \"enabled\": true,\n          \"schedule\": {\n            \"period\": {\n              \"interval\": 1,\n              \"unit\": \"MINUTES\"\n            }\n          },\n          \"inputs\": [{\n            \"search\": {\n              \"indices\": [\"movies\"],\n              \"query\": {\n                \"size\": 0,\n                \"aggregations\": {},\n                \"query\": {\n                  \"bool\": {\n                    \"adjust_pure_negative\":true,\n                    \"boost\":1,\n                    \"filter\": [{\n                      \"range\": {\n                        \"@timestamp\": {\n                          \"boost\":1,\n                          \"from\":\"||-1h\",\n                          \"to\":\"\",\n                          \"include_lower\":true,\n                          \"include_upper\":true,\n                          \"format\": \"epoch_millis\"\n                        }\n                      }\n                    }]\n                  }\n                }\n              }\n            }\n          }],\n          \"triggers\": [\n            {\n              \"name\" : \"Errors\",\n              \"severity\" : \"1\",\n              \"condition\" : {\n                \"script\" : {\n                  \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n                  \"lang\" : \"painless\"\n                }\n              },\n              \"actions\" : [\n                {\n                  \"name\" : \"Slack\",\n                  \"destination_id\" : \"${opensearch_destination.slack_on_call_channel.id}\",\n                  \"message_template\" : {\n                    \"source\" : \"bogus\",\n                    \"lang\" : \"mustache\"\n                  },\n                  \"throttle_enabled\" : false,\n                  \"subject_template\" : {\n                    \"source\" : \"Production Errors\",\n                    \"lang\" : \"mustache\"\n                  }\n                }\n              ]\n            }\n          ]\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/monitor:Monitor alert lgOZb3UB96pyyRQv0ppQ\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The monitor document\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The monitor document\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Monitor resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The monitor document\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/role:Role": {
            "description": "Provides an OpenSearch security role resource. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// To set document level permissions:\nconst writer = new opensearch.Role(\"writer\", {\n    clusterPermissions: [\"*\"],\n    indexPermissions: [{\n        allowedActions: [\"read\"],\n        documentLevelSecurity: \"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\",\n        indexPatterns: [\"pub*\"],\n    }],\n    roleName: \"foo_writer\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# To set document level permissions:\nwriter = opensearch.Role(\"writer\",\n    cluster_permissions=[\"*\"],\n    index_permissions=[opensearch.RoleIndexPermissionArgs(\n        allowed_actions=[\"read\"],\n        document_level_security=f\"{{\\\"term\\\": {{ \\\"readable_by\\\": \\\"{user['name']}\\\"}}}}\",\n        index_patterns=[\"pub*\"],\n    )],\n    role_name=\"foo_writer\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // To set document level permissions:\n        var writer = new Opensearch.Role(\"writer\", new Opensearch.RoleArgs\n        {\n            ClusterPermissions = \n            {\n                \"*\",\n            },\n            IndexPermissions = \n            {\n                new Opensearch.Inputs.RoleIndexPermissionArgs\n                {\n                    AllowedActions = \n                    {\n                        \"read\",\n                    },\n                    DocumentLevelSecurity = $\"{{\\\"term\\\": {{ \\\"readable_by\\\": \\\"{user.Name}\\\"}}}}\",\n                    IndexPatterns = \n                    {\n                        \"pub*\",\n                    },\n                },\n            },\n            RoleName = \"foo_writer\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewRole(ctx, \"writer\", \u0026opensearch.RoleArgs{\n\t\t\tClusterPermissions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tIndexPermissions: RoleIndexPermissionArray{\n\t\t\t\t\u0026RoleIndexPermissionArgs{\n\t\t\t\t\tAllowedActions: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"read\"),\n\t\t\t\t\t},\n\t\t\t\t\tDocumentLevelSecurity: pulumi.String(fmt.Sprintf(\"{\\\"term\\\": { \\\"readable_by\\\": \\\"%v\\\"}}\", user.Name)),\n\t\t\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"pub*\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"foo_writer\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Role;\nimport com.pulumi.opensearch.RoleArgs;\nimport com.pulumi.opensearch.inputs.RoleIndexPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var writer = new Role(\"writer\", RoleArgs.builder()        \n            .clusterPermissions(\"*\")\n            .indexPermissions(RoleIndexPermissionArgs.builder()\n                .allowedActions(\"read\")\n                .documentLevelSecurity(String.format(\"{{\\\"term\\\": {{ \\\"readable_by\\\": \\\"%s\\\"}}}}\", user.name()))\n                .indexPatterns(\"pub*\")\n                .build())\n            .roleName(\"foo_writer\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # To set document level permissions:\n  writer:\n    type: opensearch:Role\n    properties:\n      clusterPermissions:\n        - '*'\n      indexPermissions:\n        - allowedActions:\n            - read\n          documentLevelSecurity: '{\"term\": { \"readable_by\": \"${user.name}\"}}'\n          indexPatterns:\n            - pub*\n      roleName: foo_writer\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/role:Role writer logs_writer\n```\n\n ",
            "properties": {
                "clusterPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role.\n"
                },
                "indexPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                    },
                    "description": "A configuration of index permissions\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n"
                },
                "tenantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                    },
                    "description": "A configuration of tenant permissions\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "clusterPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role.\n"
                },
                "indexPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                    },
                    "description": "A configuration of index permissions\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n",
                    "willReplaceOnChanges": true
                },
                "tenantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                    },
                    "description": "A configuration of tenant permissions\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "clusterPermissions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of cluster permissions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the role.\n"
                    },
                    "indexPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                        },
                        "description": "A configuration of index permissions\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the security role.\n",
                        "willReplaceOnChanges": true
                    },
                    "tenantPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                        },
                        "description": "A configuration of tenant permissions\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/rolesMapping:RolesMapping": {
            "description": "Provides an OpenSearch security role mapping. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a role mapping\nconst mapper = new opensearch.RolesMapping(\"mapper\", {\n    backendRoles: [\n        \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n        \"arn:aws:iam::123456789012:role/run-containers\",\n    ],\n    description: \"Mapping AWS IAM roles to ES role\",\n    roleName: \"logs_writer\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a role mapping\nmapper = opensearch.RolesMapping(\"mapper\",\n    backend_roles=[\n        \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n        \"arn:aws:iam::123456789012:role/run-containers\",\n    ],\n    description=\"Mapping AWS IAM roles to ES role\",\n    role_name=\"logs_writer\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a role mapping\n        var mapper = new Opensearch.RolesMapping(\"mapper\", new Opensearch.RolesMappingArgs\n        {\n            BackendRoles = \n            {\n                \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n                \"arn:aws:iam::123456789012:role/run-containers\",\n            },\n            Description = \"Mapping AWS IAM roles to ES role\",\n            RoleName = \"logs_writer\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewRolesMapping(ctx, \"mapper\", \u0026opensearch.RolesMappingArgs{\n\t\t\tBackendRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/lambda-call-opensearch\"),\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/run-containers\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"Mapping AWS IAM roles to ES role\"),\n\t\t\tRoleName:    pulumi.String(\"logs_writer\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.RolesMapping;\nimport com.pulumi.opensearch.RolesMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mapper = new RolesMapping(\"mapper\", RolesMappingArgs.builder()        \n            .backendRoles(            \n                \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n                \"arn:aws:iam::123456789012:role/run-containers\")\n            .description(\"Mapping AWS IAM roles to ES role\")\n            .roleName(\"logs_writer\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a role mapping\n  mapper:\n    type: opensearch:RolesMapping\n    properties:\n      backendRoles:\n        - arn:aws:iam::123456789012:role/lambda-call-opensearch\n        - arn:aws:iam::123456789012:role/run-containers\n      description: Mapping AWS IAM roles to ES role\n      roleName: logs_writer\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/rolesMapping:RolesMapping mapper logs_writer\n```\n\n ",
            "properties": {
                "andBackendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role mapping.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of host names.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "andBackendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role mapping.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of host names.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n",
                    "willReplaceOnChanges": true
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RolesMapping resources.\n",
                "properties": {
                    "andBackendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "backendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the role mapping.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of host names.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the security role.\n",
                        "willReplaceOnChanges": true
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of users.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/script:Script": {
            "description": "Provides an Opensearch script resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a script\nconst testScript = new opensearch.Script(\"test_script\", {\n    lang: \"painless\",\n    scriptId: \"my_script\",\n    source: \"Math.log(_score * 2) + params.my_modifier\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a script\ntest_script = opensearch.Script(\"testScript\",\n    lang=\"painless\",\n    script_id=\"my_script\",\n    source=\"Math.log(_score * 2) + params.my_modifier\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a script\n        var testScript = new Opensearch.Script(\"testScript\", new Opensearch.ScriptArgs\n        {\n            Lang = \"painless\",\n            ScriptId = \"my_script\",\n            Source = \"Math.log(_score * 2) + params.my_modifier\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewScript(ctx, \"testScript\", \u0026opensearch.ScriptArgs{\n\t\t\tLang:     pulumi.String(\"painless\"),\n\t\t\tScriptId: pulumi.String(\"my_script\"),\n\t\t\tSource:   pulumi.String(\"Math.log(_score * 2) + params.my_modifier\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Script;\nimport com.pulumi.opensearch.ScriptArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testScript = new Script(\"testScript\", ScriptArgs.builder()        \n            .lang(\"painless\")\n            .scriptId(\"my_script\")\n            .source(\"Math.log(_score * 2) + params.my_modifier\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a script\n  testScript:\n    type: opensearch:Script\n    properties:\n      lang: painless\n      scriptId: my_script\n      source: Math.log(_score * 2) + params.my_modifier\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/script:Script test_script my_script\n```\n\n ",
            "properties": {
                "lang": {
                    "type": "string",
                    "description": "Specifies the language the script is written in. Defaults to painless.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n"
                },
                "source": {
                    "type": "string",
                    "description": "The source of the stored script\n"
                }
            },
            "required": [
                "scriptId",
                "source"
            ],
            "inputProperties": {
                "lang": {
                    "type": "string",
                    "description": "Specifies the language the script is written in. Defaults to painless.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "description": "The source of the stored script\n"
                }
            },
            "requiredInputs": [
                "scriptId",
                "source"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Script resources.\n",
                "properties": {
                    "lang": {
                        "type": "string",
                        "description": "Specifies the language the script is written in. Defaults to painless.\n"
                    },
                    "scriptId": {
                        "type": "string",
                        "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "description": "The source of the stored script\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/snapshotRepository:SnapshotRepository": {
            "description": "Provides an Opensearch snapshot repository resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a snapshot repository\nconst repo = new opensearch.SnapshotRepository(\"repo\", {\n    settings: {\n        bucket: \"es-index-backups\",\n        region: \"us-east-1\",\n        role_arn: \"arn:aws:iam::123456789012:role/MyRole\",\n    },\n    type: \"s3\",\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a snapshot repository\nrepo = opensearch.SnapshotRepository(\"repo\",\n    settings={\n        \"bucket\": \"es-index-backups\",\n        \"region\": \"us-east-1\",\n        \"role_arn\": \"arn:aws:iam::123456789012:role/MyRole\",\n    },\n    type=\"s3\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a snapshot repository\n        var repo = new Opensearch.SnapshotRepository(\"repo\", new Opensearch.SnapshotRepositoryArgs\n        {\n            Settings = \n            {\n                { \"bucket\", \"es-index-backups\" },\n                { \"region\", \"us-east-1\" },\n                { \"role_arn\", \"arn:aws:iam::123456789012:role/MyRole\" },\n            },\n            Type = \"s3\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewSnapshotRepository(ctx, \"repo\", \u0026opensearch.SnapshotRepositoryArgs{\n\t\t\tSettings: pulumi.AnyMap{\n\t\t\t\t\"bucket\":   pulumi.Any(\"es-index-backups\"),\n\t\t\t\t\"region\":   pulumi.Any(\"us-east-1\"),\n\t\t\t\t\"role_arn\": pulumi.Any(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"s3\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.SnapshotRepository;\nimport com.pulumi.opensearch.SnapshotRepositoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var repo = new SnapshotRepository(\"repo\", SnapshotRepositoryArgs.builder()        \n            .settings(Map.ofEntries(\n                Map.entry(\"bucket\", \"es-index-backups\"),\n                Map.entry(\"region\", \"us-east-1\"),\n                Map.entry(\"role_arn\", \"arn:aws:iam::123456789012:role/MyRole\")\n            ))\n            .type(\"s3\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a snapshot repository\n  repo:\n    type: opensearch:SnapshotRepository\n    properties:\n      settings:\n        bucket: es-index-backups\n        region: us-east-1\n        role_arn: arn:aws:iam::123456789012:role/MyRole\n      type: s3\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/snapshotRepository:SnapshotRepository repo es-index-backups\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the repository.\n"
                },
                "settings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the repository backend (required plugins must be installed).\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the repository.\n",
                    "willReplaceOnChanges": true
                },
                "settings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the repository backend (required plugins must be installed).\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SnapshotRepository resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the repository.\n",
                        "willReplaceOnChanges": true
                    },
                    "settings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the repository backend (required plugins must be installed).\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/user:User": {
            "description": "Provides an OpenSearch security user. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\n// Create a user\nconst mapper = new opensearch.User(\"mapper\", {\n    username: \"app-reasdder\",\n    password: \"SuperSekret123!\",\n    description: \"a reader role for our app\",\n});\n// And a full user, role and role mapping example:\nconst readerRole = new opensearch.Role(\"readerRole\", {\n    roleName: \"app_reader\",\n    description: \"App Reader Role\",\n    indexPermissions: [{\n        indexPatterns: [\"app-*\"],\n        allowedActions: [\n            \"get\",\n            \"read\",\n            \"search\",\n        ],\n    }],\n});\nconst readerUser = new opensearch.User(\"readerUser\", {\n    username: \"app-reader\",\n    password: _var.password,\n});\nconst readerRolesMapping = new opensearch.RolesMapping(\"readerRolesMapping\", {\n    roleName: readerRole.id,\n    description: \"App Reader Role\",\n    users: [readerUser.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\n# Create a user\nmapper = opensearch.User(\"mapper\",\n    username=\"app-reasdder\",\n    password=\"SuperSekret123!\",\n    description=\"a reader role for our app\")\n# And a full user, role and role mapping example:\nreader_role = opensearch.Role(\"readerRole\",\n    role_name=\"app_reader\",\n    description=\"App Reader Role\",\n    index_permissions=[opensearch.RoleIndexPermissionArgs(\n        index_patterns=[\"app-*\"],\n        allowed_actions=[\n            \"get\",\n            \"read\",\n            \"search\",\n        ],\n    )])\nreader_user = opensearch.User(\"readerUser\",\n    username=\"app-reader\",\n    password=var[\"password\"])\nreader_roles_mapping = opensearch.RolesMapping(\"readerRolesMapping\",\n    role_name=reader_role.id,\n    description=\"App Reader Role\",\n    users=[reader_user.id])\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        // Create a user\n        var mapper = new Opensearch.User(\"mapper\", new Opensearch.UserArgs\n        {\n            Username = \"app-reasdder\",\n            Password = \"SuperSekret123!\",\n            Description = \"a reader role for our app\",\n        });\n        // And a full user, role and role mapping example:\n        var readerRole = new Opensearch.Role(\"readerRole\", new Opensearch.RoleArgs\n        {\n            RoleName = \"app_reader\",\n            Description = \"App Reader Role\",\n            IndexPermissions = \n            {\n                new Opensearch.Inputs.RoleIndexPermissionArgs\n                {\n                    IndexPatterns = \n                    {\n                        \"app-*\",\n                    },\n                    AllowedActions = \n                    {\n                        \"get\",\n                        \"read\",\n                        \"search\",\n                    },\n                },\n            },\n        });\n        var readerUser = new Opensearch.User(\"readerUser\", new Opensearch.UserArgs\n        {\n            Username = \"app-reader\",\n            Password = @var.Password,\n        });\n        var readerRolesMapping = new Opensearch.RolesMapping(\"readerRolesMapping\", new Opensearch.RolesMappingArgs\n        {\n            RoleName = readerRole.Id,\n            Description = \"App Reader Role\",\n            Users = \n            {\n                readerUser.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewUser(ctx, \"mapper\", \u0026opensearch.UserArgs{\n\t\t\tUsername:    pulumi.String(\"app-reasdder\"),\n\t\t\tPassword:    pulumi.String(\"SuperSekret123!\"),\n\t\t\tDescription: pulumi.String(\"a reader role for our app\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treaderRole, err := opensearch.NewRole(ctx, \"readerRole\", \u0026opensearch.RoleArgs{\n\t\t\tRoleName:    pulumi.String(\"app_reader\"),\n\t\t\tDescription: pulumi.String(\"App Reader Role\"),\n\t\t\tIndexPermissions: RoleIndexPermissionArray{\n\t\t\t\t\u0026RoleIndexPermissionArgs{\n\t\t\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"app-*\"),\n\t\t\t\t\t},\n\t\t\t\t\tAllowedActions: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"get\"),\n\t\t\t\t\t\tpulumi.String(\"read\"),\n\t\t\t\t\t\tpulumi.String(\"search\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treaderUser, err := opensearch.NewUser(ctx, \"readerUser\", \u0026opensearch.UserArgs{\n\t\t\tUsername: pulumi.String(\"app-reader\"),\n\t\t\tPassword: pulumi.Any(_var.Password),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewRolesMapping(ctx, \"readerRolesMapping\", \u0026opensearch.RolesMappingArgs{\n\t\t\tRoleName:    readerRole.ID(),\n\t\t\tDescription: pulumi.String(\"App Reader Role\"),\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\treaderUser.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.User;\nimport com.pulumi.opensearch.UserArgs;\nimport com.pulumi.opensearch.Role;\nimport com.pulumi.opensearch.RoleArgs;\nimport com.pulumi.opensearch.inputs.RoleIndexPermissionArgs;\nimport com.pulumi.opensearch.RolesMapping;\nimport com.pulumi.opensearch.RolesMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mapper = new User(\"mapper\", UserArgs.builder()        \n            .username(\"app-reasdder\")\n            .password(\"SuperSekret123!\")\n            .description(\"a reader role for our app\")\n            .build());\n\n        var readerRole = new Role(\"readerRole\", RoleArgs.builder()        \n            .roleName(\"app_reader\")\n            .description(\"App Reader Role\")\n            .indexPermissions(RoleIndexPermissionArgs.builder()\n                .indexPatterns(\"app-*\")\n                .allowedActions(                \n                    \"get\",\n                    \"read\",\n                    \"search\")\n                .build())\n            .build());\n\n        var readerUser = new User(\"readerUser\", UserArgs.builder()        \n            .username(\"app-reader\")\n            .password(var_.password())\n            .build());\n\n        var readerRolesMapping = new RolesMapping(\"readerRolesMapping\", RolesMappingArgs.builder()        \n            .roleName(readerRole.id())\n            .description(\"App Reader Role\")\n            .users(readerUser.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a user\n  mapper:\n    type: opensearch:User\n    properties:\n      username: app-reasdder\n      password: SuperSekret123!\n      description: a reader role for our app\n  # And a full user, role and role mapping example:\n  readerRole:\n    type: opensearch:Role\n    properties:\n      roleName: app_reader\n      description: App Reader Role\n      indexPermissions:\n        - indexPatterns:\n            - app-*\n          allowedActions:\n            - get\n            - read\n            - search\n  readerUser:\n    type: opensearch:User\n    properties:\n      username: app-reader\n      password: ${var.password}\n  readerRolesMapping:\n    type: opensearch:RolesMapping\n    properties:\n      roleName: ${readerRole.id}\n      description: App Reader Role\n      users:\n        - ${readerUser.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/user:User reader app_reader\n```\n\n ",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a\npassword policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS Opensearch domains\n\"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit,\nand one special character\".\n"
                },
                "passwordHash": {
                    "type": "string",
                    "description": "The pre-hashed password for the user, cannot be specified with `password`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The name of the security user.\n"
                }
            },
            "required": [
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a\npassword policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS Opensearch domains\n\"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit,\nand one special character\".\n"
                },
                "passwordHash": {
                    "type": "string",
                    "description": "The pre-hashed password for the user, cannot be specified with `password`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The name of the security user.\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                    },
                    "backendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a\npassword policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS Opensearch domains\n\"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit,\nand one special character\".\n"
                    },
                    "passwordHash": {
                        "type": "string",
                        "description": "The pre-hashed password for the user, cannot be specified with `password`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The name of the security user.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "opensearch:index/getDestination:getDestination": {
            "description": "`opensearch.Destination` can be used to retrieve the destination object by name.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = pulumi.output(opensearch.getDestination({\n    name: \"my-destination\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.get_destination(name=\"my-destination\")\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Opensearch.GetDestination.InvokeAsync(new Opensearch.GetDestinationArgs\n        {\n            Name = \"my-destination\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.LookupDestination(ctx, \u0026GetDestinationArgs{\n\t\t\tName: \"my-destination\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.OpensearchFunctions;\nimport com.pulumi.opensearch.inputs.GetDestinationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = OpensearchFunctions.getDestination(GetDestinationArgs.builder()\n            .name(\"my-destination\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    Fn::Invoke:\n      Function: opensearch:getDestination\n      Arguments:\n        name: my-destination\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDestination.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDestination.\n",
                "properties": {
                    "body": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "body",
                    "name",
                    "id"
                ]
            }
        },
        "opensearch:index/getHost:getHost": {
            "description": "`opensearch.getHost` can be used to retrieve the host URL for the provider's current cluster.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = pulumi.output(opensearch.getHost({\n    active: true,\n}));\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.get_host(active=True)\n```\n```csharp\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = Output.Create(Opensearch.GetHost.InvokeAsync(new Opensearch.GetHostArgs\n        {\n            Active = true,\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.GetHost(ctx, \u0026GetHostArgs{\n\t\t\tActive: true,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.OpensearchFunctions;\nimport com.pulumi.opensearch.inputs.GetHostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = OpensearchFunctions.getHost(GetHostArgs.builder()\n            .active(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    Fn::Invoke:\n      Function: opensearch:getHost\n      Arguments:\n        active: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "active"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "active": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "url": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "active",
                    "url",
                    "id"
                ]
            }
        }
    }
}